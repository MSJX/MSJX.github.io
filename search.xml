<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Django+Nginx post 500</title>
      <link href="/2019/02/22/django-nginx/"/>
      <url>/2019/02/22/django-nginx/</url>
      
        <content type="html"><![CDATA[<h3 id="Django-Nginx-uWsgi-的错误记录"><a href="#Django-Nginx-uWsgi-的错误记录" class="headerlink" title="Django + Nginx  + uWsgi 的错误记录"></a>Django + Nginx  + uWsgi 的错误记录</h3><p>记录我出现server error 500的原因：模板中使用了filter，没有加到服务器代码上，因此模板在渲染的时候出现了如下错误：</p><pre><code>django.template.exceptions.TemplateSyntaxError: Invalid filter</code></pre><p>但是在查看uWsgi.log的日志文件并没有log信息，</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 16.04 Django部署（Nginx + uWsgi + Supervisor）</title>
      <link href="/2019/01/26/djangodeploy/"/>
      <url>/2019/01/26/djangodeploy/</url>
      
        <content type="html"><![CDATA[<h2 id="Ubuntu-16-04-Python3环境安装"><a href="#Ubuntu-16-04-Python3环境安装" class="headerlink" title="Ubuntu 16.04 Python3环境安装"></a>Ubuntu 16.04 Python3环境安装</h2><ol><li><p>安装可能使用到的依赖</p><p><code>apt get install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel</code></p></li><li><p>从Python官网找到需要的Python版本的下载路径，使用<code>wget</code>下载到服务器</p><p>这里以Python3.6.7为例：<a href="https://www.python.org/ftp/python/3.6.7/Python-3.6.7.tgz" target="_blank" rel="noopener">https://www.python.org/ftp/python/3.6.7/Python-3.6.7.tgz</a></p><p>下载到服务器命令：<code>wget https://www.python.org/ftp/python/3.6.7/Python-3.6.7.tgz</code></p></li><li><p>解压tgz压缩包</p><p><code>tar -zxvf Python-3.6.7.tgz</code></p><p>解压完可以在当前目录下看到Python-3.6.7的目录</p></li><li><p>把Python移到 <strong>/usr/local</strong> 下</p><p><code>mv Python-3.6.7 /usr/local</code></p></li><li><p>进入Python-3.6.7目录</p><p><code>cd /usr/local/Python-3.6.7</code></p></li><li><p>配置</p><p><code>./configure</code></p></li><li><p>编译</p><p><code>make</code></p></li><li><p>安装</p><p><code>make install</code></p></li><li><p>创建软链接（以便在全局调用）</p><p><code>ln -s /usr/local/bin/python3.6 /usr/bin/python3</code></p></li><li><p>查看是否安装成功</p><p><code>python3 -V</code></p><p><img src="http://blog.aicircle.site/img/django-deploy/python.png" alt=""></p></li></ol><h2 id="将项目传到到服务器"><a href="#将项目传到到服务器" class="headerlink" title="将项目传到到服务器"></a>将项目传到到服务器</h2><p>这里我们使用Git来操作，我们把项目传到如：Github或Coding等代码仓库，然后使用Git克隆到服务器。这样每次项目更新了只要将代码上传到仓库，在到服务器将代码拉下来就可以实现代码更新了</p><ol><li><p>项目配置</p><p>记得在项目的<strong>settings.py</strong>中添加以下配置</p><pre class=" language-python"><code class="language-python">DEBUG <span class="token operator">=</span> <span class="token boolean">False</span>ALLOWED_HOSTS <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'你的公网ip(不带端口号)'</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 如果不配置服务器的IP地址将导致外网无法访问，或者使用['*']代表授权全部</span>STATIC_URL <span class="token operator">=</span> <span class="token string">'/static/'</span>STATIC_ROOT <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>BASE_DIR<span class="token punctuation">,</span> <span class="token string">'static'</span><span class="token punctuation">)</span></code></pre></li><li><p>安装Git</p><p><code>apt get install git</code></p></li><li><p>克隆项目到服务器</p><p><code>git clone http://xxxxxx.com</code>，将<code>http://xxxxxx.com</code>换成自己仓库的地址</p></li><li><p>拉取更新的代码</p><p><code>git pull</code></p></li><li><p>更多</p><p>更多的Git命令可以查看我另一篇文章：<a href="https://smileorigin.site/2017/10/18/Git/Git/" target="_blank" rel="noopener">https://smileorigin.site/2017/10/18/Git/Git/</a></p></li></ol><h2 id="使用Virtualenv来创建虚拟环境"><a href="#使用Virtualenv来创建虚拟环境" class="headerlink" title="使用Virtualenv来创建虚拟环境"></a>使用Virtualenv来创建虚拟环境</h2><p>为每一个Django项目都创建一个虚拟环境可以使每个项目的依赖包都互不影响，也不会污染全局环境，其他使用和信息可以查看我的另一篇文章–<a href="https://smileorigin.site/2018/08/06/Python/Virtualenv/" target="_blank" rel="noopener">https://smileorigin.site/2018/08/06/Python/Virtualenv/</a></p><ol><li><p>更新pip</p><p><code>pip3 install --upgrade pip</code></p></li><li><p>安装Virtualenv</p><p><code>pip3 install virtualenv</code></p></li><li><p>进入项目所在文件夹</p><p>假设我们项目文件夹在当前目录且名称为<code>server</code></p><p><code>cd server</code></p></li><li><p>创建虚拟环境</p><p>在当前文件夹下创建一个名为<strong>venv</strong>的虚拟环境</p><p><code>virtualenv venv</code></p></li><li><p>激活虚拟环境</p><p><code>source venv/bin/activate</code></p><p>可以看到在<strong>root</strong>之前多了个<strong>(venv)</strong>，说明激活虚拟环境成功了</p><p><img src="http://blog.aicircle.site/img/django-deploy/virtualenv-create.png" alt=""></p></li><li><p>使用<code>requirements.txt</code>文件安装依赖包</p><p>如果有使用<code>pip freeze &gt;requirements.txt</code>在本地项目导出项目的所有依赖包，则可以通过该命令进行快速安装依赖包，没有的话就手动使用pip安装项目需要的依赖包</p><p><code>pip install -r requirements.txt</code></p></li></ol><h2 id="安装配置uWsgi"><a href="#安装配置uWsgi" class="headerlink" title="安装配置uWsgi"></a>安装配置uWsgi</h2><ol><li><p>安装</p><p><code>pip install uwsgi</code></p></li><li><p>测试uwsgi</p><p><code>vim test.py</code></p><p>填写以下内容</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">application</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> start_response<span class="token punctuation">)</span><span class="token punctuation">:</span>    start_response<span class="token punctuation">(</span><span class="token string">'200 OK'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'text/html'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span>b<span class="token string">'Hello world'</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># Python3</span></code></pre><p>保存后，执行指令进行测试：<code>uwsgi --http 127.0.0.1:8000 --wsgi-file test.py</code></p><p>如果执行成功，则会有以下类似信息：</p><p><img src="http://blog.aicircle.site/img/django-deploy/uwsgi-test2.png" alt=""></p><p>打开另一个命令行窗口，输入以下命令进行测试：<code>curl 127.0.0.1:8000</code></p><p>如果提示以下信息则表示测试页面运行成功：</p><p>可以看到截图有显示：<code>Hello world</code></p><p><img src="http://blog.aicircle.site/img/django-deploy/uwsgi-test-result.png" alt=""></p></li><li><p>新建uwsgi配置文件</p><p><code>vim uwsgi.ini</code></p><p>可以按照以下模板进行填写</p><pre class=" language-shell"><code class="language-shell">[uwsgi]# 我的项目目录chdir = /root/server# 指定项目的applicationmodule = imageAnalyze.wsgi# 进程个数workers = 5#pid文件保存路径pidfile = /root/server/uwsgi/uwsgi.pid# 指定IP端口http = 127.0.0.1:8000# 指定静态文件static-map = /static=/root/server/static# 启动uwsgi的用户名和用户组uid = rootgid = root# 启用主进程master = true# 自动移除unix Socket和pid文件当服务停止的时候vacuum = true# 序列化接受的内容，如果可能的话thunder-lock = true# 启用线程enable-threads = true# 设置自中断时间harakiri = 30# 设置缓冲post-buffering = 4096# 设置日志目录daemonize = /root/server/uwsgi/uwsgi.log# 指定sock的文件路径socket = /root/server/uwsgi/uwsgi.sock</code></pre></li><li><p>新建配置文件中的指定文件夹</p><p>如果不创建可能导致以配置文件启动uwsgi报文件夹不存在的错误</p><p><code>mkdir uwsgi</code></p></li><li><p>创建static文件夹</p><p><code>mkdir static</code></p></li><li><p>收集项目静态文件</p><p><code>python manage.py collectstatic</code></p><p><img src="http://blog.aicircle.site/img/django-deploy/uwsgi-collect-static.png" alt=""></p><p>收集成功会提示收集的文件数</p></li><li><p>以配置文件的形式启动uwsgi</p><p><code>uwsgi --ini uwsgi.ini</code></p><p>如果启动成功，则有以下类似提示</p><p><img src="http://blog.aicircle.site/img/django-deploy/uwsgi-start.png" alt=""></p><p>使用<code>netstat -tnlp</code>命令可以查看在有哪些端口是运行的，可以看到uwsgi运行在<strong>127.0.0.1:8000</strong></p><p><img src="http://blog.aicircle.site/img/django-deploy/uwsgi-start-port.png" alt=""></p></li><li><p>关闭uwsgi</p><p><code>kill -9 30117</code>，30117为上图中uwsgi的PID</p></li></ol><h2 id="安装配置Nginx"><a href="#安装配置Nginx" class="headerlink" title="安装配置Nginx"></a>安装配置Nginx</h2><p>记得在配置Nginx的时候如果使用的是阿里云服务器，要让外部使用的端口要先在阿里云服务器的安全组中打开，否则会不能访问</p><ol><li><p>查找要安装的Nginx的包链接</p><p><a href="http://nginx.org/packages/centos/7/x86_64/RPMS/" target="_blank" rel="noopener">http://nginx.org/packages/centos/7/x86_64/RPMS/</a></p></li><li><p>安装</p><p><code>rpm -ivh http://nginx.org/packages/centos/7/x86_64/RPMS/nginx-1.14.1-1.el7_4.ngx.x86_64.rpm</code></p></li><li><p>配置Django项目的Nginx配置文件</p><p><code>cd /etc/nginx/conf.d</code></p><p><code>vim server.conf</code>，创建你项目的Nginx的配置文件，把<code>server</code>换成任意名字（<code>/etc/nginx/nginx.conf</code>文件的最后一行是<code>include /etc/nginx/conf.d/*.conf;</code>会加载<code>/etc/nginx/conf.d</code>文件夹下的所有后缀为<code>.conf</code>的配置文件，所以只要在这个目录下创建后缀为<code>.conf</code>的配置文件并配置相关内容，Nginx就会自动帮我们加载了，不需要额外的处理）</p><pre class=" language-shell"><code class="language-shell">server{    listen 80; # 监听的端口    server_name cookbook.aicircle.site;    server_name www.cookbook.aicircle.site # 使外部可通过www.cookbook.aicircle.site进行访问    #当请求这些server name的时候，nginx才会做反向代理，0.0.0.0是指全部    location / {      proxy_pass http://127.0.0.1:8000;      proxy_set_header Host $host;      proxy_set_header X-Real-IP $remote_addr;      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header X-Forwarded-Proto $scheme;    }    # location 顾名思义，定位，就是当访问 / 的时候，nginx会将请求转给本地的8080>端口，而后面的设置都是>一些基本的配置，可以直接用    location /static {      alias /root/server/static;    }    # 这个就是配置静态文件的地方，要用绝对地址，对应最开始的目录形式，假设project就在/home下面，那么这>样配置就可以的了，还有个前提是，你在开发的时候，采取了django的建议，每个app的静态文件都用多了一层app_name的文件夹来包住。}</code></pre></li><li><p>查看Nginx状态</p><p><code>systemctl status nginx</code>，如果Nginx是启动的则会有以下类似提示：</p><p><img src="http://blog.aicircle.site/img/django-deploy/nginx-status.png" alt=""></p></li><li><p>测试Nginx配置文件是否有误</p><p><code>nginx -t</code>，如果有以下类似提示，则配置文件没错</p><p><img src="http://blog.aicircle.site/img/django-deploy/nginx-test-config.png" alt=""></p></li><li><p>启动Nginx</p><p><code>systemctl start nginx</code></p></li><li><p>测试是否启动成功</p><p><code>curl http://127.0.0.1:80</code>，如果Nginx启动成功，则会显示以下类似内容</p><p><img src="http://blog.aicircle.site/img/django-deploy/nginx-curl-test.png" alt=""></p></li><li><p>设置开机自启</p><p><code>systemctl enable nginx</code>，如果设置成功则会有类似提示信息</p><p><img src="http://blog.aicircle.site/img/django-deploy/nginx-boot-start.png" alt=""></p></li><li><p>关闭Nginx</p><p><code>systemctl stop nginx</code></p></li><li><p>重启Nginx</p><p><code>systemctl restart nginx</code></p></li></ol><h2 id="使用Supervisor来管理进程"><a href="#使用Supervisor来管理进程" class="headerlink" title="使用Supervisor来管理进程"></a>使用Supervisor来管理进程</h2><blockquote><p>Supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。它是通过fork/exec的方式把这些被管理的进程当作supervisor的子进程来启动，这样只要在supervisor的配置文件中，把要管理的进程的可执行文件的路径写进去，就可以实现当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息，可以选择是否重新启动程序或报警。supervisor还提供了一个功能，可以为supervisord或者每个子进程，设置一个非root的user，这个user就可以管理它对应的进程。</p></blockquote><ol><li><p>安装</p><p>安装我们使用Center OS自带的Python2来安装，Supervisor不支持Python3，打开另一个命令窗口使用以下命令安装</p><p><code>pip2 install supervisor</code></p></li><li><p>设置配置文件</p><p><code>vim supervisord.conf</code>，在任意你想要的位置创建配置文件，根据说明将以下参数改为自己的配置，保存</p><pre class=" language-shell"><code class="language-shell">[program:server]command=/root/server/venv/bin/uwsgi --ini /root/server/uwsgi.inidirectory=/root/server startsecs=1 stopwaitsecs=1 autostart=true autorestart=true [supervisord][supervisorctl]</code></pre><ul><li><code>program:server</code>：指定程序名称，<code>server</code>为自定义程序名称</li><li><code>command</code>：启动程序的命令，这里是调用虚拟环境内的uwsgi根据配置文件<code>/root/server/uwsgi.ini</code>启动Django程序</li><li><code>directory</code>：项目所在的文件夹</li><li><code>startsecs</code>：启动延迟</li><li><code>stopwaitsecs</code>：关闭延迟</li><li><code>autostart</code>：是否自动启动</li><li><code>autorestart</code>：是否自动重启</li></ul></li><li><p>启动Supervisor</p><p>supervisord是服务端，supervisorctl是客户端</p><p><code>supervisord -c supervisord.conf</code>，如果<code>surpervisord.conf</code>不在当前文件夹则需要其绝对路径（如：<code>/etc/xx/supervisord.conf</code>）</p></li><li><p>重启supervisor</p><p><code>service supervisord restart</code></p></li><li><p>启动进程</p><p><code>supervisorctl -c supervisord.conf start server</code></p></li><li><p>重启进程</p><p><code>supervisorctl -c supervisord.conf restart server</code></p></li><li><p>关闭进程</p><p><code>supervisorctl -c supervisord.conf stop server</code></p></li><li><p>启动所有进程</p><p><code>supervisorctl start all</code></p></li><li><p>关闭所有进程</p><p><code>supervisorctl stop all</code></p></li><li><p>查看所有进程的状态</p><p><code>supervisorctl status</code></p></li><li><p>查看Supervisor的进程信息</p><p><code>ps -ef | grep supervisord</code></p></li></ol><h2 id="错误解决方案"><a href="#错误解决方案" class="headerlink" title="错误解决方案"></a>错误解决方案</h2><ul><li><p>如果以上都配置好了，发现进入网站静态文件无法正常加载，请确认你的项目是不是在<code>/root</code>文件夹下，如果是的话则在修改<code>root</code>目录的权限</p><p><code>chmod -R 755 root</code></p><p>修改完后重启Nginx服务器重新访问网站即可</p></li><li><p>无法访问服务器（博主这边用的是阿里云服务器，默认防火墙是关闭的）</p><ol><li>检查服务器防火墙是否将用到的端口都设为白名单</li><li>如果是阿里云服务器，检查安全组是否添加用到的端口为入方向白名单</li></ol></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/wjy397/article/details/51610872" target="_blank" rel="noopener">超详细的django1.8处理centos下nginx上处理静态文件步骤！</a></li><li><p><a href="https://www.cnblogs.com/EasonJim/p/9020896.html" target="_blank" rel="noopener">CentOS 6.9/7通过yum安装指定版本的Nginx</a></p></li><li><p><a href="https://code.ziqiangxuetang.com/django/django-nginx-deploy.html" target="_blank" rel="noopener">Django部署(Nginx)</a></p></li><li><p><a href="http://blog.51cto.com/mbb97/2151933" target="_blank" rel="noopener">结合Nginx+uWsgi部署Django项目</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
            <tag> Nginx </tag>
            
            <tag> uWsgi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python AES and RSA</title>
      <link href="/2019/01/08/python-jia-mi-jie-mi/"/>
      <url>/2019/01/08/python-jia-mi-jie-mi/</url>
      
        <content type="html"><![CDATA[<h3 id="PyCryptodome包"><a href="#PyCryptodome包" class="headerlink" title="PyCryptodome包"></a>PyCryptodome包</h3><p>​    <strong>PyCryto</strong>应该是Python最著名的第三方库了，奈何 <strong>PyCryto</strong> 在2012年的时候就停止更新了。值得庆幸的是，在Python 3.x上有了一个名为 <strong>PyCryptodome</strong> 的库来代替<strong>PyCryto</strong>，下面简单介绍一下 <strong>PyCryptodome</strong> 这个库的用法，主要是 <strong>AES</strong> 结合 <strong>RSA</strong> 使用。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><p><strong>Linux</strong></p><pre class=" language-python"><code class="language-python">pip install pycryptodome</code></pre></li><li><p><strong>Windows</strong></p><pre class=" language-Python"><code class="language-Python">pip install pycryptodomex</code></pre></li></ul><h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><p>​    <strong>高级加密标准</strong>（英文：<strong>Advanced Encryption Standard</strong>，缩写：<strong>AES</strong>），在密码学中又称 <strong>Rijndael 加密法</strong>，是美国联邦政府采用的一种区块加密标准。</p><ul><li><p><strong>加密</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Cipher <span class="token keyword">import</span> AES<span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Random <span class="token keyword">import</span> get_random_byteskey <span class="token operator">=</span> get_random_bytes<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">encrypto</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>    data <span class="token operator">=</span> content<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    cipher <span class="token operator">=</span> AES<span class="token punctuation">.</span>new<span class="token punctuation">(</span>key<span class="token punctuation">,</span> AES<span class="token punctuation">.</span>MODE_EAX<span class="token punctuation">)</span>    nonce <span class="token operator">=</span> nonce    cipher_text<span class="token punctuation">,</span> tag <span class="token operator">=</span> cipher<span class="token punctuation">.</span>encrypt_and_digest<span class="token punctuation">(</span>data<span class="token punctuation">)</span>    <span class="token keyword">return</span> cipher_text<span class="token keyword">print</span><span class="token punctuation">(</span>encrypt<span class="token punctuation">(</span><span class="token string">'Test Python AES'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><pre class=" language-python"><code class="language-python">E<span class="token punctuation">:</span><span class="token operator">/</span>company<span class="token operator">/</span><span class="token number">1226</span><span class="token operator">/</span>JsonRPC<span class="token operator">/</span>en_decode<span class="token operator">/</span>AES_crypto<span class="token punctuation">.</span>pyb<span class="token string">'u\xed\xdc=D\x17\x83\xac\xbf\xc5\xe5p5A\x1a'</span>Process finished <span class="token keyword">with</span> exit code <span class="token number">0</span></code></pre></li></ul><ul><li><p><strong>解密</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Cipher <span class="token keyword">import</span> AES<span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Random <span class="token keyword">import</span> get_random_byteskey <span class="token operator">=</span> get_random_bytes<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">decrypt</span><span class="token punctuation">(</span>cipher_text<span class="token punctuation">)</span><span class="token punctuation">:</span>    cipher <span class="token operator">=</span> AES<span class="token punctuation">.</span>new<span class="token punctuation">(</span>key<span class="token punctuation">,</span> AES<span class="token punctuation">.</span>MODE_EAX<span class="token punctuation">,</span> nonce<span class="token operator">=</span>nonce<span class="token punctuation">)</span>    plaintext <span class="token operator">=</span> <span class="token punctuation">(</span>cipher<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span>cipher_text<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        cipher<span class="token punctuation">.</span>verify<span class="token punctuation">(</span>tag<span class="token punctuation">)</span>        <span class="token keyword">return</span> plaintext    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"key incorrect or message corrupted"</span></code></pre><pre class=" language-python"><code class="language-python">E<span class="token punctuation">:</span><span class="token operator">/</span>company<span class="token operator">/</span><span class="token number">1226</span><span class="token operator">/</span>JsonRPC<span class="token operator">/</span>en_decode<span class="token operator">/</span>AES_crypto<span class="token punctuation">.</span>pyTest Python AESProcess finished <span class="token keyword">with</span> exit code <span class="token number">0</span></code></pre><p>解密过程中的 <strong>key、nonce、tag</strong> 必须与 <strong>cipher_text</strong> 在加密过程中生成的 <strong>key、nonce、tag</strong> 一致，否则会报错。</p></li><li><p><strong>封装成一个类</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Cipher <span class="token keyword">import</span> AES<span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Random <span class="token keyword">import</span> get_random_bytes<span class="token keyword">class</span> <span class="token class-name">AESCrypto</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    key <span class="token operator">=</span> get_random_bytes<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 加密</span>    <span class="token keyword">def</span> <span class="token function">encrypt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">:</span>        data <span class="token operator">=</span> content<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>        cipher <span class="token operator">=</span> AES<span class="token punctuation">.</span>new<span class="token punctuation">(</span>self<span class="token punctuation">.</span>key<span class="token punctuation">,</span> AES<span class="token punctuation">.</span>MODE_EAX<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>nonce <span class="token operator">=</span> cipher<span class="token punctuation">.</span>nonce        self<span class="token punctuation">.</span>cipher_text<span class="token punctuation">,</span> self<span class="token punctuation">.</span>tag <span class="token operator">=</span> cipher<span class="token punctuation">.</span>encrypt_and_digest<span class="token punctuation">(</span>data<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>cipher_text    <span class="token comment" spellcheck="true"># 解密</span>    <span class="token keyword">def</span> <span class="token function">decrypt</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        cipher <span class="token operator">=</span> AES<span class="token punctuation">.</span>new<span class="token punctuation">(</span>self<span class="token punctuation">.</span>key<span class="token punctuation">,</span> AES<span class="token punctuation">.</span>MODE_EAX<span class="token punctuation">,</span> nonce<span class="token operator">=</span>self<span class="token punctuation">.</span>nonce<span class="token punctuation">)</span>        plaintext <span class="token operator">=</span> <span class="token punctuation">(</span>cipher<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span>self<span class="token punctuation">.</span>cipher_text<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            cipher<span class="token punctuation">.</span>verify<span class="token punctuation">(</span>self<span class="token punctuation">.</span>tag<span class="token punctuation">)</span>            <span class="token keyword">return</span> plaintext        <span class="token keyword">except</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">"key incorrect or message corrupted"</span></code></pre></li></ul><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>​    <strong>RSA 加密算法</strong>是一种<font color="red"><strong>非对称加密算法</strong></font>。在公开密钥加密和电子商业中RSA被广泛使用。</p><p>​    该算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但那时想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥，即公钥，而两个大素数组合成私钥。公钥是可发布的供任何人使用，私钥则为自己所有，供解密之用</p><ul><li><p><strong>Linux安装</strong></p><pre class=" language-python"><code class="language-python">pip install rsa</code></pre></li></ul><ul><li><p><strong>使用</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> rsa<span class="token comment" spellcheck="true"># 加密</span><span class="token keyword">def</span> <span class="token function">rsa_encrypted</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 生成公钥、私钥</span>    pub_key<span class="token punctuation">,</span> priv_key <span class="token operator">=</span> rsa<span class="token punctuation">.</span>newkeys<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 明文编码格式</span>    content <span class="token operator">=</span> msg<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 公钥加密</span>    crypto <span class="token operator">=</span> rsa<span class="token punctuation">.</span>encrypt<span class="token punctuation">(</span>content<span class="token punctuation">,</span> pub_key<span class="token punctuation">)</span>    <span class="token keyword">return</span> crypto<span class="token punctuation">,</span> priv_key<span class="token comment" spellcheck="true"># 解密</span><span class="token keyword">def</span> <span class="token function">rsa_decrypted</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> priv_key<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 私钥解密</span>    content <span class="token operator">=</span> rsa<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span>msg<span class="token punctuation">,</span> priv_key<span class="token punctuation">)</span>    data <span class="token operator">=</span> content<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> data</code></pre><p>如果单独使用 <strong>RSA</strong> 进行加密的话，加密的内容长度会受到<strong>公钥</strong>和<strong>私钥</strong>的 <font color="red"><strong>bytes</strong></font> 影响，所以，这个时候会就需要用到文章开头所说的，<strong>AES + RSA</strong>来进行加密。</p></li></ul><h3 id="AES-RSA"><a href="#AES-RSA" class="headerlink" title="AES + RSA"></a>AES + RSA</h3><ul><li><p><strong>生成一个RSA密钥</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>PublicKey <span class="token keyword">import</span> RSAcode <span class="token operator">=</span> <span class="token string">'nooneknows'</span>key <span class="token operator">=</span> RSA<span class="token punctuation">.</span>generate<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span>encrypted_key <span class="token operator">=</span> key<span class="token punctuation">.</span>exportKey<span class="token punctuation">(</span>passphrase<span class="token operator">=</span>code<span class="token punctuation">,</span> pkcs<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span>                              protection<span class="token operator">=</span><span class="token string">"scryptAndAES128-CBC"</span><span class="token punctuation">)</span><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'private_key.pem'</span><span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>encrypted_key<span class="token punctuation">)</span><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'public_key.pem'</span><span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>key<span class="token punctuation">.</span>publickey<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>exportKey<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>首先我们从 <strong><font color="red">Crypto.PublicKey</font></strong> 引入 <strong>RSA</strong>，然后创建一个密码。接下来我们生成一个2048位的 <strong>RSA</strong> 对象实例。我们需要调用 <strong>RSA</strong> 实例的 <strong>exportKey</strong> 方法并传递给它刚刚创建的密码，<strong>PKCS</strong> 标准算法将会用它保护我们的私钥。接下来我们将生成的私钥写入文件。</p><p>下一步我们通过 <strong>RSA</strong> 实例的 <strong>publickey</strong> 方法生成公钥，我们在这段代码中用了简写的方式将 <strong>publickey</strong> 和 <strong>exportKey</strong> 方法串接起来，最后也将结果写入文件。</p></li><li><p><strong>对文件进行加密</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>PublicKey <span class="token keyword">import</span> RSA<span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Random <span class="token keyword">import</span> get_random_bytes<span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Cipher <span class="token keyword">import</span> AES<span class="token punctuation">,</span> PKCS1_OAEP<span class="token keyword">def</span> <span class="token function">encrypt</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'encrypted_data.bin'</span><span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> out_file<span class="token punctuation">:</span>        recipient_key <span class="token operator">=</span> RSA<span class="token punctuation">.</span>import_key<span class="token punctuation">(</span>            open<span class="token punctuation">(</span><span class="token string">'public_key.pem'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        session_key <span class="token operator">=</span> get_random_bytes<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span>        cipher_rsa <span class="token operator">=</span> PKCS1_OAEP<span class="token punctuation">.</span>new<span class="token punctuation">(</span>recipient_key<span class="token punctuation">)</span>        out_file<span class="token punctuation">.</span>write<span class="token punctuation">(</span>cipher_rsa<span class="token punctuation">.</span>encrypt<span class="token punctuation">(</span>session_key<span class="token punctuation">)</span><span class="token punctuation">)</span>        cipher_aes <span class="token operator">=</span> AES<span class="token punctuation">.</span>new<span class="token punctuation">(</span>session_key<span class="token punctuation">,</span> AES<span class="token punctuation">.</span>MODE_EAX<span class="token punctuation">)</span>        data <span class="token operator">=</span> content<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>        cipher_text<span class="token punctuation">,</span> tag <span class="token operator">=</span> cipher_aes<span class="token punctuation">.</span>encrypt_and_digest<span class="token punctuation">(</span>data<span class="token punctuation">)</span>        out_file<span class="token punctuation">.</span>write<span class="token punctuation">(</span>cipher_aes<span class="token punctuation">.</span>nonce<span class="token punctuation">)</span>        out_file<span class="token punctuation">.</span>write<span class="token punctuation">(</span>tag<span class="token punctuation">)</span>        out_file<span class="token punctuation">.</span>write<span class="token punctuation">(</span>cipher_text<span class="token punctuation">)</span>    <span class="token keyword">return</span> cipher_text</code></pre><p>前三行完成对<font color="red"><strong>PyCryptodome</strong></font>的引入，接下来打开将要写入的文件。然后我们将公钥读入变量并创建一个16字节长的 <strong>session key</strong>。在这个例子中我们用了混合加密方法，因此我们使用最优非对称加密填充的 <strong>PKCS#1 OAEP</strong>。这让我们可以将任意长度的数据写入文件。接下来我们创建 <strong>AES</strong> 密文，创建一些数据并进行加密，这一方法会返回加密后的文本和 <strong>MAC</strong> 值。最终我们将 <code>nonce</code>，<code>MAC</code>(或<code>tag</code>)以及加密后的文本写入文件。</p><p>说明一下，<code>nonce</code> 是一个任意数字，仅用于密文通信。它们通常是随机或伪随机数。对于 <strong>AES</strong> 来说，它的长度至少要是16位。你可以用你的文本编辑器打开加密后的文件看一下，只能看到一堆乱码。</p></li><li><p><strong>对文件进行解密</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>PublicKey <span class="token keyword">import</span> RSA<span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Random <span class="token keyword">import</span> get_random_bytes<span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Cipher <span class="token keyword">import</span> AES<span class="token punctuation">,</span> PKCS1_OAEP<span class="token keyword">def</span> <span class="token function">decrypt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    secret_code <span class="token operator">=</span> <span class="token string">'nooneknows'</span>    <span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'encrypted_data.bin'</span><span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fp<span class="token punctuation">:</span>        private_key <span class="token operator">=</span> RSA<span class="token punctuation">.</span>import_key<span class="token punctuation">(</span>            open<span class="token punctuation">(</span><span class="token string">'private_key.pem'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> passphrase<span class="token operator">=</span>secret_code<span class="token punctuation">)</span>        enc_session_key<span class="token punctuation">,</span> nonce<span class="token punctuation">,</span> tag<span class="token punctuation">,</span> cipher_text <span class="token operator">=</span> \            <span class="token punctuation">[</span>fp<span class="token punctuation">.</span>read<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token punctuation">(</span>private_key<span class="token punctuation">.</span>size_in_bytes<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                                               <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        cipher_rsa <span class="token operator">=</span> PKCS1_OAEP<span class="token punctuation">.</span>new<span class="token punctuation">(</span>private_key<span class="token punctuation">)</span>        cipher_aes <span class="token operator">=</span> AES<span class="token punctuation">.</span>new<span class="token punctuation">(</span>session_key<span class="token punctuation">,</span> AES<span class="token punctuation">.</span>MODE_EAX<span class="token punctuation">,</span> nonce<span class="token punctuation">)</span>        data <span class="token operator">=</span> cipher_aes<span class="token punctuation">.</span>decrypt_and_verify<span class="token punctuation">(</span>cipher_text<span class="token punctuation">,</span> tag<span class="token punctuation">)</span>    <span class="token keyword">return</span> data<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span></code></pre><p>在这个例子中，我们以二进制模式打开加密文件，然后导入私钥。要注意在导入私钥的时候，必须给出你的密码，即在生成 <strong>RSA</strong> 密钥时自己定义的<code>code = &#39;nooneknows&#39;</code>，否则将会出错。接下来我们读取加密文件，需要注意的是先读取私钥，然后是16位长的 <code>nonce</code>，接下来是另外 16 位长的标签，最后剩下的才是我们的数据。</p><p>接下来我们需要解密 <strong>session key</strong>，重新生成 <strong>AES key</strong> 并解密数据。</p></li></ul><h3 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h3><ul><li><a href="https://juejin.im/entry/575fae92df0eea0062c5a1dc" target="_blank" rel="noopener">探索 Python 3 加密技术</a></li><li><a href="https://pycryptodome.readthedocs.io/en/latest/src/examples.html#encrypt-data-with-aes" target="_blank" rel="noopener">PyCryptodome</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Basics</title>
      <link href="/2018/09/20/python-ji-chu/"/>
      <url>/2018/09/20/python-ji-chu/</url>
      
        <content type="html"><![CDATA[<ul><li><p>尽量用<strong>enumerate</strong>取代<strong>range</strong>：</p><p>Python提供了一个内置函数enumerate，可以把各种<strong>迭代器</strong>包装成为一个<strong>生成器</strong>，生成器每次产生一对输出值，前者表示<strong>循环下标</strong>，后者表示从迭代器获取到的下一个<strong>序列元素</strong>。这样写出来的代码非常简洁。</p><pre class=" language-python"><code class="language-python">flavor_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'vanilla'</span><span class="token punctuation">,</span><span class="token string">'chocolate'</span><span class="token punctuation">,</span><span class="token string">'pecan'</span><span class="token punctuation">,</span><span class="token string">'strawberry'</span><span class="token punctuation">]</span><span class="token keyword">for</span> i<span class="token punctuation">,</span>flavor <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>flavor_list<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%d : %s'</span> <span class="token operator">%</span> （<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span>）<span class="token punctuation">,</span>flavor<span class="token punctuation">)</span>）</code></pre><pre><code>&gt;&gt;&gt;1 : vanilla2 : chocolate3 : pecan4 : strawberry</code></pre><p>（<strong>注</strong>：列表的下标从0开始的）</p><p>还可以直接指定enumerate函数开始时所用的值，如下所示：</p><pre class=" language-python"><code class="language-python">flavor_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'vanilla'</span><span class="token punctuation">,</span><span class="token string">'chocolate'</span><span class="token punctuation">,</span><span class="token string">'pecan'</span><span class="token punctuation">,</span><span class="token string">'strawberry'</span><span class="token punctuation">]</span><span class="token keyword">for</span> i<span class="token punctuation">,</span>flavor <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>flavor_list<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%d : %s'</span> <span class="token operator">%</span> （i<span class="token punctuation">,</span>flavor<span class="token punctuation">)</span>）</code></pre><pre><code>&gt;&gt;&gt;1 : vanilla2 : chocolate3 : pecan4 : strawberry</code></pre><ul><li>enumerate函数提供了一种精简的写法，可以在遍历迭代器时获知每个元素的索引。</li><li>尽量用enumerate来改写那种将range与下标访问相结合的序列遍历代码。</li><li>可以给enumerate提供第二个参数，以指定开始计数时所用的值（默认是0）。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL存储过程</title>
      <link href="/2018/08/23/mysql-cun-chu-guo-cheng/"/>
      <url>/2018/08/23/mysql-cun-chu-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是存储过程"><a href="#什么是存储过程" class="headerlink" title="什么是存储过程"></a>什么是存储过程</h3><ul><li><p>存储过程是存储在数据库服务器中的一组SQL语句，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数（需要时）来调用执行 。</p><p>存储过程可以用来封装特定功能，以便应用于不同的平台，可以看做对面向对象编程的模拟 </p></li></ul><h3 id="存储过程的优点"><a href="#存储过程的优点" class="headerlink" title="存储过程的优点"></a>存储过程的优点</h3><ul><li>存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般 SQL 语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。</li><li>当对数据库进行复杂操作时(如对多个表进行 Update,Insert,Query,Delete 时），可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。这些操作，如果用程序来完成，就变成了一条条的 SQL 语句，可能要多次连接数据库。而换成存储，只需要连接一次数据库就可以了。 </li><li>存储过程可以重复使用,可减少数据库开发人员的工作量。 </li><li>安全性高,可设定只有某此用户才具有对指定存储过程的使用权。 </li></ul><h3 id="存储过程的缺点"><a href="#存储过程的缺点" class="headerlink" title="存储过程的缺点"></a>存储过程的缺点</h3><ul><li>运行速度：对于很简单的SQL，存储过程没有什么优势。 </li><li>网络负荷：如果在存储过程中没有进行多次的数据交互，那么实际上网络传输量和直接使用SQL是一样的 。</li><li>开发调试：由于IDE的问题，存储过程的开发调试要比一般程序困难 。</li></ul><h3 id="创建MySQL存储过程"><a href="#创建MySQL存储过程" class="headerlink" title="创建MySQL存储过程"></a>创建MySQL存储过程</h3><ul><li><p>语法：</p><pre class=" language-mysql"><code class="language-mysql">delimiter //create procedure procedure_name(params)begin    procedure bodyend //delimiter;</code></pre><p>（<strong>注：</strong>在Navicat Lite中，新建函数，可直接在过程体中写入要完成的功能，非常方便。）</p></li><li><p>调用：</p><pre><code>call procedure_name(params)</code></pre></li><li><p>分隔符：</p><p>MySQL默认以”;”为分隔符，如果没有声明分隔符，则编译器会把存储过程当成SQL语句进行处理，因此编译过程会报错，所以要先用“DELIMITER //”声明当前段分隔符，让编译器把两个“//“之间的内容当做存储过程的代码，不会执行这些代码，“DELIMITER ;”意为把分隔符还原 。</p></li><li><p>参数：</p><p>存储过程根据需要可能会有输入、输出、输入输出参数，如果有多个参数用“,”分隔开。MySQL存储过程的参数用在存储过程的定义，共有三种类型：in、out、inout。</p><ul><li><p>in：</p><p>参数的值必须在调用存储过程前指定，在存储过程中修改该参数的值不能被返回</p><p>即类似JAVA中的值传递，传递的相当于参数的值的拷贝，而不是参数本身。</p></li><li><p>out：</p><p>该值可在存储过程内部被改变，并可返回，未在存储过程中赋值的话，则在存储过程中值为空</p><p>即类似JAVA中的引用传递，传递的是该参数本身的地址，该参数在存储过程中被修改相当于直接修改该参数本身。</p></li><li><p>inout：</p><p>具备IN、OUT的特性，在调用时指定，并可被改变和返回 。</p></li></ul></li><li><p>过程体（procedure body）：</p><p>完成某种特定的功能（自己指定）,过程体的开始与结束使用<strong>BEGIN</strong>和<strong>END</strong>进行标识 。</p></li><li><p>in实例：</p><pre class=" language-mysql"><code class="language-mysql">delimiter //create procedure pro_in(in p_in int)begin    select p_in;    set p_in = 1;    select p_in;end;//</code></pre><pre><code>mysql&gt; drop procedure if exists in_param;Query OK, 0 rows affected (0.00 sec)mysql&gt; delimiter //mysql&gt; create procedure in_param(in p_in int)    -&gt; begin    -&gt; select p_in;    -&gt; set p_in = 2;    -&gt; select p_in;    -&gt; end;    -&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; set @p_in=1;    -&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; call in_param(@p_in);    -&gt; //+------+| p_in |+------+|    1 |+------+1 row in set (0.00 sec)+------+| p_in |+------+|    2 |+------+1 row in set (0.03 sec)Query OK, 0 rows affected (0.06 sec)mysql&gt; select @p_in;    -&gt; //+-------+| @p_in |+-------+|     1 |+-------+1 row in set (0.00 sec)</code></pre><p>从运行结果可以得出，p_in虽然在存储过程中被修改了，但并不影响存储过程外的@p_in的值 。</p></li><li><p>out实例：</p><pre><code>delimiter //create procedure pro_out(out p_out int)begin    select p_out;    set p_out = 2;    select p_out;end;//</code></pre><pre><code>mysql&gt; delimiter //mysql&gt; create procedure out_param(out p_out int)    -&gt; begin    -&gt; select p_out;    -&gt; set p_out = 2;    -&gt; select p_out;    -&gt; end;    -&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; delimiter ;mysql&gt; set @p_out = 1;Query OK, 0 rows affected (0.00 sec)mysql&gt; call out_param(@p_out);+-------+| p_out |+-------+|  NULL |+-------+1 row in set (0.01 sec)+-------+| p_out |+-------+|     2 |+-------+1 row in set (0.03 sec)Query OK, 0 rows affected (0.06 sec)mysql&gt; select @p_out;+--------+| @p_out |+--------+|      2 |+--------+1 row in set (0.00 sec)</code></pre><p>从运行结果可以得出，p_out在存储过程中没被赋值的情况下是读取不到数据的，赋值后再存储过程外的@p_out的值也被修改了 。</p></li><li><p>inout实例：</p><pre><code>mysql&gt; delimiter //mysql&gt; create procedure inout_param(inout p_inout int)    -&gt; begin    -&gt; select p_inout;    -&gt; set p_inout = 2;    -&gt; select p_inout;    -&gt; end;    -&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; set @p_inout = 1;    -&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; call inout_param(@p_inout);    -&gt; //+---------+| p_inout |+---------+|       1 |+---------+1 row in set (0.00 sec)+---------+| p_inout |+---------+|       2 |+---------+1 row in set (0.03 sec)Query OK, 0 rows affected (0.06 sec)mysql&gt; select @p_inout;    -&gt; //+----------+| @p_inout |+----------+|        2 |+----------+1 row in set (0.00 sec)</code></pre><p>从运行结果可以得出，inout参数结合了in和out的特点，传进去的参数既可以读取又可以修改 。</p></li><li><p>删除存储过程：</p><ul><li><p>语法：</p><pre><code>drop procedure procedure_name;</code></pre></li><li><p>example:</p><pre><code>mysql&gt; drop procedure in_param;    -&gt; //Query OK, 0 rows affected (0.00 sec)</code></pre></li></ul></li><li><p>存储过程实现模糊查询（Navicat Lite为例）：</p><pre class=" language-mysql"><code class="language-mysql">create procedure pro_fruits_search_sort(in name varchar(20)):beginselect fname,fprice,fcount,fprice*fcount as total from fruits_table where fname like concat('%',name,'%'); end</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EffectivePython Advices Record</title>
      <link href="/2018/08/07/advices/"/>
      <url>/2018/08/07/advices/</url>
      
        <content type="html"><![CDATA[<h2 id="不要通过检测长度的方法来判断somelist是否为空"><a href="#不要通过检测长度的方法来判断somelist是否为空" class="headerlink" title="不要通过检测长度的方法来判断somelist是否为空"></a>不要通过检测长度的方法来判断somelist是否为空</h2><p>不要使用如：<code>if len(somelist) &gt; 0</code>来判断somelist是否为<strong>[]</strong>或<strong>“空值”</strong>，而是应该采用<code>if not somelist</code>这种写法来判断，somelist为空值或者None表达式<code>not somelist</code>都将会为True</p><p>检测子元素somelist[i]也应该使用这种方法</p><p>Example</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> None<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">if</span> <span class="token operator">not</span> a<span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"I'm none."</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> I'm none<span class="token punctuation">.</span><span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">if</span> <span class="token operator">not</span> b<span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"I'm empty list."</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> I'm empty list<span class="token punctuation">.</span><span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">if</span> <span class="token operator">not</span> c<span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"I'm empty dictionary."</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> I'm empty dictionary<span class="token punctuation">.</span></code></pre><h2 id="编写Python程序的时候一定要把编码和解码放在界面最外围来做"><a href="#编写Python程序的时候一定要把编码和解码放在界面最外围来做" class="headerlink" title="编写Python程序的时候一定要把编码和解码放在界面最外围来做"></a>编写Python程序的时候一定要把编码和解码放在界面最外围来做</h2><p>程序的核心部分应该使用Unicode字符类型（也就是Python3中的str，Python2中的unicode），而且不要对字符编码做任何假设。这种办法可以另程序接受多种类型的文本编码（Latin-1、Shift JIS和Big5），又可以保证输出的文本信息只采用一种编码形式（最好是UTF-8）</p><p>由于Python的字符类型有别，所以Python代码中经常会出现两种使用场景：</p><ul><li>开发者需要原始8位值，这些8位值表示以UTF-8格式或其他编码形式来编码的字符</li><li>开发者需要操作没有特定编码形式的Unicode字符</li></ul><p>所以我们需要编写两个辅助函数，以便在这两种情况之间转换，使得转换后的输入数据能够符合开发者的预期</p><p>在Python3中，我们需要编写接受str或bytes，并总返回str的方法：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">to_str</span><span class="token punctuation">(</span>bytes_or_str<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>bytes_or_str<span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">:</span>        value <span class="token operator">=</span> bytes_or_str<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        value <span class="token operator">=</span> bytes_or_str    <span class="token keyword">return</span> value</code></pre><p>另外还需要接受str或bytes，并总是返回bytes的方法</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">to_bytes</span><span class="token punctuation">(</span>bytes_or_str<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>bytes_or_str<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>        value <span class="token operator">=</span> bytes_or_str<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        value <span class="token operator">=</span> bytes_or_str    <span class="token keyword">return</span> value</code></pre><h2 id="用zip函数同时遍历两个迭代器"><a href="#用zip函数同时遍历两个迭代器" class="headerlink" title="用zip函数同时遍历两个迭代器"></a>用zip函数同时遍历两个迭代器</h2><p>在编写Python代码时，我们通常要面对很多个列表，而这些列表里的对象，可能也是相互关联的。通过列表推导，很容易就能根据某个表达式从源列表推算出一份派生类表</p><pre class=" language-python"><code class="language-python">names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Cecilia'</span><span class="token punctuation">,</span> <span class="token string">'Lise'</span><span class="token punctuation">,</span> <span class="token string">'Marie'</span><span class="token punctuation">]</span>letters <span class="token operator">=</span> <span class="token punctuation">[</span>len<span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token keyword">for</span> n <span class="token keyword">in</span> names<span class="token punctuation">]</span></code></pre><p>对于本例中的派生列表和源列表来说，相同索引处的两个元素之间有着关联。如果想平行地迭代这两份列表，那么可根据names源列表的长度来执行循环</p><pre class=" language-python"><code class="language-python">longest_name <span class="token operator">=</span> Nonemax_letters <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>names<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> letters<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token keyword">if</span> count <span class="token operator">></span> max_letters<span class="token punctuation">:</span>        longest_name <span class="token operator">=</span> names<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        max_letter <span class="token operator">=</span> count<span class="token keyword">print</span><span class="token punctuation">(</span>longest_name<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span>Cecilia</code></pre><p>上面这段代码的问题在于，整个循环语句看上去很乱。用下标来访问names和letters会使代码不易阅读。用循环下标i来访问数组的写法一共出现了两次。改用enumerate来做可以稍微缓解这个问题。但是仍然不够理想</p><pre class=" language-python"><code class="language-python"><span class="token keyword">for</span> i<span class="token punctuation">,</span> name <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>names<span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> letters<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token keyword">if</span> count <span class="token operator">></span> max_letters<span class="token punctuation">:</span>        longest_name <span class="token operator">=</span> names<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        max_letters <span class="token operator">=</span> count</code></pre><p>使用内置的<strong>zip</strong>函数能够使上述代码变得更加简洁。在Python3中的<strong>zip</strong>函数，可以把两个或者两个以上的迭代器封装为生成器，以便稍后求值。这种zip生成器，会从每个迭代器中获取该迭代器的下一个值，然后把这些值汇聚成元组。与通过下标来访问多份列表的那种写法相比，这种用zip写出来的代码更加明晰</p><pre class=" language-python"><code class="language-python"><span class="token keyword">for</span> name<span class="token punctuation">,</span> count <span class="token keyword">in</span> zip<span class="token punctuation">(</span>names<span class="token punctuation">,</span> letters<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> count <span class="token operator">></span> max_letters<span class="token punctuation">:</span>        longest_name <span class="token operator">=</span> name        max_letters <span class="token operator">=</span> count    </code></pre><p><strong>zip</strong>存在一个问题，如果两个迭代器的长度不一致，<strong>zip</strong>会自动提前终止</p><p><strong>itertools</strong>内置模块中的<strong>zip_longest</strong>函数可以平行地遍历多个迭代器，而不用在乎它们的长度是否相等</p><h2 id="try-except-else"><a href="#try-except-else" class="headerlink" title="try/except/else"></a>try/except/else</h2><p><strong>try/except/else</strong> 结构可以清晰地描述出哪些异常会由自己的代码来处理、哪些异常会传播到上一级。如果try块没有发生异常，那么就执行else块。有了这种else块，我们可以尽量缩减try块内的代码量，使其更加易读。例如，要从字符串中加载JSON字典数据，然后返回字典里某个键所对应的值</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">load_json</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        result_dict <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># May raise ValueError</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> KeyError <span class="token keyword">from</span> e    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> result_dict<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># May raise KeyError</span></code></pre><p>如果数据不是有效的JSON格式，那么用json.loads解码时，会产生ValueError。这个异常会由except块来捕获并处理。如果能够解码，那么else块里的查找语句就会执行，它会根据键来查出相关的值。查询时若有异常，则该异常会向上传播，因为查询语句并不在刚才那个try块的范围内。这种else子句，会把try/except后面的内容和except本身区分开，使异常的传播行为变得更加清晰</p><h2 id="用生成器表达式来改写数据量较大的列表推导式"><a href="#用生成器表达式来改写数据量较大的列表推导式" class="headerlink" title="用生成器表达式来改写数据量较大的列表推导式"></a>用生成器表达式来改写数据量较大的列表推导式</h2><p>列表推导缺点–在推导过程中，对于输入序列中的每个值来说，可能都要创建仅含一项元素的全新列表。当输入的数据比较少时，不会出现问题，但如果输入的数据非常多，那么可能会消耗大量的内存，并导致程序崩溃</p><p>例如要读取一份文件并返回每行的字符数。若采用列表推导来做，则需要把文件每一行的长度都保存在内存中。如果这个文件特别大，或者是通过无休止的network socket来读取，那么这种列表推到就会出问题。下面这段列表推到代码，只适合处理少量的输入值</p><pre class=" language-python"><code class="language-python">value <span class="token operator">=</span> <span class="token punctuation">[</span>len<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> open<span class="token punctuation">(</span><span class="token string">'/tmp/test_file.txt'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">43</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">]</span></code></pre><p>为了解决此问题，Python提供了生成器表达式，它是对列表推导和生成器的一种泛化。生成器表达式在运行的时候，并不会把整个输出序列都呈现出来，而是会估值为迭代器，这个迭代器每次可以根据生成器表达式产生一项数据。把实现列表推到所用的那种写法放在一对括号中，就构成了生成器表达式。下面给出的生成器表达式与刚才的代码等效。二者的区别在于，对于生成器表达式求值的时候，它会立刻返回一个迭代器，而不会深入文件中的内容。以刚才返回的迭代器为参数，逐次调用内置的next函数，即可使其按照生成器表达式来输出下一个值。可以根据自己的需求，多次命令迭代器根据生成器表达式来生成新值，而不用担心内存用量激增</p><pre class=" language-python"><code class="language-python">it <span class="token operator">=</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> open<span class="token punctuation">(</span><span class="token string">'/tmp/test_file.txt'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>next<span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>next<span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token number">2</span><span class="token number">100</span></code></pre><p>使用生成器表达式还有个好处，就是可以相互组合。下面代码会把刚那个生成器表达式所返回的迭代器用作另一个生成器表达式的输入值。外围的迭代器每次前进时，都会推动内部那个迭代器，这就产生了连锁效应，使得执行循环、评估条件表达式、对接输入和输出等逻辑都组合在一起。这种连锁生成器表达式，可以迅速在Python中执行。如果要吧多种手法组合起来，以操作大批量的输入数据，那最好用生成器表达式来实现。只是要注意：由生成器表达式所返回的那个迭代器是有状态的，用过一轮之后，就不要反复使用了</p><pre class=" language-python"><code class="language-python">roots <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> x<span class="token operator">**</span><span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> it<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>next<span class="token punctuation">(</span>roots<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">)</span></code></pre><h2 id="考虑用生成器来改写直接返回列表的函数"><a href="#考虑用生成器来改写直接返回列表的函数" class="headerlink" title="考虑用生成器来改写直接返回列表的函数"></a>考虑用生成器来改写直接返回列表的函数</h2><p>如果函数要产生一系列结果，那么最简单的做法就是把这些结果都放在一份列表里，并将其返回给调用者。例如：我们要查出字符串中每个词的首字母在整个字符串里的位置。下面这段代码，用append方法将这些词的首字母索引添加到result列表中，并在函数结束时将其返回给调用者</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">index_words</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> text<span class="token punctuation">:</span>        result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> index<span class="token punctuation">,</span> letter <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> letter <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">:</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> result</code></pre><p>输入一些范例值，以验证该函数能够正常运作：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> address <span class="token operator">=</span> <span class="token string">'Four score and seven years age...'</span><span class="token operator">>></span><span class="token operator">></span> result <span class="token operator">=</span> index_words<span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span></code></pre><p>第一个问题是，这个代码写得有点拥挤。每次找到新的结果，都要调用append方法。但我们真正应该强调的，并不是对result.append方法的调用，而是该方法给列表中添加的那个值，也就是index + 1。另外，函数首尾还有一行代码用来创建及返回result列表。于是，在函数主体部分的约130个字符里，重要的大概只有75个</p><p>这个函数改用生成器（generator）来写会更好。生成器是使用<strong>yield</strong>表达式的函数。调用函数时，它并不是真正的运行，而是会返回生成器。每次在这个迭代器上面调用内置的next函数时，迭代器会把生成器推进到下一个yield表达式那里。生成器传给<strong>yield</strong>的每一个值都会由迭代器返回给调用者</p><p>下面的这个生成器函数，会产生和刚才那个函数相同的效果</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">index_words_iter</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> text<span class="token punctuation">:</span>        <span class="token keyword">yield</span> <span class="token number">0</span>    <span class="token keyword">for</span> index<span class="token punctuation">,</span> letter <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> letter <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">:</span>            <span class="token keyword">yield</span> index <span class="token operator">+</span> <span class="token number">1</span></code></pre><pre class=" language-python"><code class="language-python">result <span class="token operator">=</span> list<span class="token punctuation">(</span>index_words_iter<span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span></code></pre><p>这个函数不需要包含域result列表相交互的那些代码，因而看起来比刚才那种写法清晰许多。原来那个result列表中的元素，现在都分别传给<strong>yield</strong>表达式了。调用该生成器后所返回的迭代器，可以传给内置的list函数，以将其转换为列表</p><h2 id="使用None和文档字符串来描述具有动态默认值的参数"><a href="#使用None和文档字符串来描述具有动态默认值的参数" class="headerlink" title="使用None和文档字符串来描述具有动态默认值的参数"></a>使用None和文档字符串来描述具有动态默认值的参数</h2><p>有时我们想采用一种非静态的类型，来做关键字参数的默认值。例如：在打印日志消息的时候，要把相关事件的记录时间也标注在这条消息中。默认情况下，消息里面所包含的时间，应该是调用<strong>log</strong>函数那一刻的时间。如果我们以为参数的默认值会在每次执行函数时得到评估，那可能就会写出下面这种代码</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> when<span class="token operator">=</span>datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%s : %s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>when<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> log<span class="token punctuation">(</span><span class="token string">'Hi there!'</span><span class="token punctuation">)</span><span class="token number">2018</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">08</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">41</span><span class="token punctuation">:</span><span class="token number">37.025822</span> <span class="token punctuation">:</span> Hi there!<span class="token operator">>></span><span class="token operator">></span> time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> log<span class="token punctuation">(</span><span class="token string">'Hi again!'</span><span class="token punctuation">)</span><span class="token number">2018</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">08</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">41</span><span class="token punctuation">:</span><span class="token number">37.025822</span> <span class="token punctuation">:</span> Hi again!</code></pre><p>两条消息的时间戳是一样的，这是因为datetime.now()只执行了一次，也就是它只在函数定义的时候执行了一次。参数的默认值，会在每个模块加载进来的时候求出，而很多模块都是在程序启动的时候加载的。包含这段代码的模块一旦加载进来参数的默认值也就固定不变了，程序不会再次执行datetime.now()。</p><p>True Example</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> when<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     when <span class="token operator">=</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> when <span class="token keyword">is</span> None <span class="token keyword">else</span> when<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%s : %s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>when<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">>></span><span class="token operator">></span> log<span class="token punctuation">(</span><span class="token string">'Hi there!'</span><span class="token punctuation">)</span><span class="token number">2018</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">08</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">48</span><span class="token punctuation">:</span><span class="token number">01.383500</span> <span class="token punctuation">:</span> Hi there!<span class="token operator">>></span><span class="token operator">></span> log<span class="token punctuation">(</span><span class="token string">'Hi again!'</span><span class="token punctuation">)</span><span class="token number">2018</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">08</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">48</span><span class="token punctuation">:</span><span class="token number">06.394290</span> <span class="token punctuation">:</span> Hi again!</code></pre><p>默认值为字典的错误情况实例</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> json<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">decode</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">try</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token keyword">return</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">except</span> ValueError<span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token keyword">return</span> default<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">>></span><span class="token operator">></span> foo <span class="token operator">=</span> decode<span class="token punctuation">(</span><span class="token string">'bad data'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> foo<span class="token punctuation">[</span><span class="token string">'stuff'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token operator">>></span><span class="token operator">></span> bar <span class="token operator">=</span> decode<span class="token punctuation">(</span><span class="token string">'also bad'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> bar<span class="token punctuation">[</span><span class="token string">'meep'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Foo:'</span><span class="token punctuation">,</span> foo<span class="token punctuation">)</span>Foo<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'stuff'</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'meep'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Bar:'</span><span class="token punctuation">,</span> bar<span class="token punctuation">)</span>Bar<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'stuff'</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'meep'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span></code></pre><p>True Example</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">decode</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> default<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> default <span class="token keyword">is</span> None<span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             default <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">try</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token keyword">return</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">except</span> ValueError<span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token keyword">return</span> default<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">>></span><span class="token operator">></span> foo <span class="token operator">=</span> decode<span class="token punctuation">(</span><span class="token string">'bad data'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> foo<span class="token punctuation">[</span><span class="token string">'stuff'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token operator">>></span><span class="token operator">></span> bar <span class="token operator">=</span> decode<span class="token punctuation">(</span><span class="token string">'also bad'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> bar<span class="token punctuation">[</span><span class="token string">'meep'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Foo:'</span><span class="token punctuation">,</span> foo<span class="token punctuation">)</span>Foo<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'stuff'</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Bar:'</span><span class="token punctuation">,</span> bar<span class="token punctuation">)</span>Bar<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'meep'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span></code></pre><h2 id="用只能以关键字形式指定的参数来确保代码明晰"><a href="#用只能以关键字形式指定的参数来确保代码明晰" class="headerlink" title="用只能以关键字形式指定的参数来确保代码明晰"></a>用只能以关键字形式指定的参数来确保代码明晰</h2><p>下面定义的这个safe_division_c函数，带有两个只能以关键字形式来指定的参数。参数列表里的*号，标志着位置参数就此终结，之后那些参数，都只能以关键字形式来指定</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">safe_division_c</span><span class="token punctuation">(</span>number<span class="token punctuation">,</span> divisor<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> ignore_overflow<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> ignore_zero_division<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span></code></pre><p>现在，我们就不用位置参数的形式来指定关键字参数了</p><pre class=" language-python"><code class="language-python">safe_division_c<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">**</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span>TypeError<span class="token punctuation">:</span> safe_division_c<span class="token punctuation">(</span><span class="token punctuation">)</span> takes <span class="token number">2</span> positional arguments but <span class="token number">4</span> were given</code></pre><p>关键字参数依然可以用关键字的形式来指定，如果不指定，也依然会采用默认值</p><pre class=" language-python"><code class="language-python">safe_division_c<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ignore_zero_division<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># OK</span><span class="token keyword">try</span><span class="token punctuation">:</span>    safe_division_c<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">except</span> ZeroDivisionError<span class="token punctuation">:</span>    <span class="token keyword">pass</span>     <span class="token comment" spellcheck="true"># Excepted</span></code></pre><h2 id="使用内置算法与数据结构"><a href="#使用内置算法与数据结构" class="headerlink" title="使用内置算法与数据结构"></a>使用内置算法与数据结构</h2><p>如果Python程序要处理的数量比较可观，那么代码的执行速度会受到复杂算法拖累。然而这并不能证明Python是一门执行速度很低的语言，因为这种情况很可能是算法和数据结构选择不佳导致的</p><p>幸运的是Python的标准程序库里面，内置了各种算法与数据结构，以供开发者使用。这些常见的算法与数据结构，不仅执行速度比较快，而且还可以简化编程工作。其中某些实用工具，是很难由开发者自己正确实现出来的。所以，我们应该直接使用这些Python自带的功能，而不要重新去实现它们，以节省时间和精力</p><h3 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h3><p><strong>collections</strong>模块中的<strong>deque</strong>类，是一种双向队列（double-ended queue，双端队列）。从该队列的头部或者尾部插入或移除一个元素，只需要消耗常数级别的时间，这一特性使得它非常适合用来表示先进先出队列。内置的list类型，也可以像队列那样，按照一定的顺序来存放元素。从list尾部插入或者移除元素，也仅仅需要常熟级别的时间。但是，从list头部插入或者移除元素，却会耗费线性级别的时间，这与deque的常数级别时间相比，要慢得多</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">from</span> time <span class="token keyword">import</span> timestart <span class="token operator">=</span> time<span class="token punctuation">(</span><span class="token punctuation">)</span>fifo <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Producter</span>fifo<span class="token punctuation">.</span>extend<span class="token punctuation">(</span><span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">200000</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Consumer</span><span class="token keyword">while</span> len<span class="token punctuation">(</span>fifo<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>    x <span class="token operator">=</span> fifo<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>end <span class="token operator">=</span> time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'deque: {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>end<span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span>start <span class="token operator">=</span> time<span class="token punctuation">(</span><span class="token punctuation">)</span>l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>l<span class="token punctuation">.</span>extend<span class="token punctuation">(</span><span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">200000</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">while</span> len<span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>    x <span class="token operator">=</span> l<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>end <span class="token operator">=</span> time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'list: {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>end<span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><pre class=" language-shell"><code class="language-shell"># 可看到在20万级数据下一直移除第一个元素双向队列的效率要高得非常多deque: 0.08118391036987305list: 4.417634010314941</code></pre><h3 id="有序字典"><a href="#有序字典" class="headerlink" title="有序字典"></a>有序字典</h3><p>标准字典是无序的。也就是说在拥有相同键值对的两个dict上面迭代，可能会出现不同的迭代顺序。标准的字典之所以会出现这种奇怪的现象，是由其快速哈希表（fast hash table）的实现方式导致的</p><p><strong>collections</strong>模块中的<strong>OrderedDict</strong>类，是一种特殊的字典，它能按照键的插入顺序，来保存键值对在字典中的次序。在OrderedDict上面根据键来迭代，其行为是确定的。这种确定的行为，可以极大地简化测试与调试工作</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> OrderedDicta <span class="token operator">=</span> OrderedDict<span class="token punctuation">(</span><span class="token punctuation">)</span>a<span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>a<span class="token punctuation">[</span><span class="token string">'bar'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>b <span class="token operator">=</span> OrderedDict<span class="token punctuation">(</span><span class="token punctuation">)</span>b<span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'red'</span>b<span class="token punctuation">[</span><span class="token string">'bar'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'blue'</span><span class="token keyword">for</span> value1<span class="token punctuation">,</span> value2 <span class="token keyword">in</span> zip<span class="token punctuation">(</span>a<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>value1<span class="token punctuation">,</span> value2<span class="token punctuation">)</span></code></pre><h3 id="带有默认值的字典"><a href="#带有默认值的字典" class="headerlink" title="带有默认值的字典"></a>带有默认值的字典</h3><p>字典可以用来保存一些统计数据。但是，由于字典里面未必有我们要查询的那个键，所以在用字典保存计数器的时候，就必须用稍微麻烦一些的方式，才能够实现这种简单的功能</p><pre class=" language-python"><code class="language-python">stats <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>key <span class="token operator">=</span> <span class="token string">'my_counter'</span><span class="token keyword">if</span> key <span class="token operator">not</span> <span class="token keyword">in</span> stats<span class="token punctuation">:</span>    stats<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>stats<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span></code></pre><p>我们可以用collections模块中的defaultdict类来简化上述代码。如果字典中没有待访问的键，那么它就会把某个默认值与这个键自动关联起来。于是，我们只要提供返回默认值的函数即可，字典会调用该函数为每一个默认的键指定默认值</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdictdict <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>dict<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># out</span><span class="token number">0</span></code></pre><h3 id="堆队列"><a href="#堆队列" class="headerlink" title="堆队列"></a>堆队列</h3><p>堆（heap）是一种数据结构，很适合用来实现优先级队列。heapq模块提供了<strong>heappush</strong>、<strong>heappop</strong>和<strong>nsmallest</strong>等一些函数，能够在标准的list类型之中创建堆结构</p><p>各种优先级的元素，都可以按任意顺序插入堆中</p><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span>heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Before: '</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用sort后依然能保持堆的结构，但是添加reverse后就不能保持堆结构了</span><span class="token comment" spellcheck="true"># a.sort()</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'After； '</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 按照优先级弹出元素的，数值越小优先级越大</span><span class="token keyword">print</span><span class="token punctuation">(</span>heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>在list上面使用index方法来搜索某个元素，所耗的时间会与列表的长度成线性比例。</p><pre class=" language-python"><code class="language-python">x <span class="token operator">=</span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">**</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>i <span class="token operator">=</span> x<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token number">991234</span><span class="token punctuation">)</span></code></pre><p><strong>bisect</strong>模块中的bisect_left等函数，提供了高效的二分折半搜索算法，能够在一系列排好顺序的元素之中搜寻某个值。由bisect_left函数所返回的索引，表示待搜寻的值在序列中的插入点（将该值插在此处，能够使序列依然保持有序）</p><pre class=" language-python"><code class="language-python">i<span class="token operator">=</span> bisect_left<span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">991234</span><span class="token punctuation">)</span></code></pre><p>二分搜算法的复杂度，是对数级别的。这就意味着，用bisect来搜索包含一百个元素的列表，与用index来搜索包含14个元素的列表，所耗费的时间差不多。由此可见，这种对数级别的算法，要比线性级别的算法快很多</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> bisect <span class="token keyword">import</span> bisect_left<span class="token keyword">from</span> time <span class="token keyword">import</span> timea <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">]</span>start <span class="token operator">=</span> time<span class="token punctuation">(</span><span class="token punctuation">)</span>bisect_left<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">9000</span><span class="token punctuation">)</span>end <span class="token operator">=</span> time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'bisect: {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span>start <span class="token operator">=</span> time<span class="token punctuation">(</span><span class="token punctuation">)</span>a<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token number">9000</span><span class="token punctuation">)</span>end <span class="token operator">=</span> time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'list: {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 运行结果</span>bisect<span class="token punctuation">:</span> <span class="token number">1.3828277587890625e-05</span>list<span class="token punctuation">:</span> <span class="token number">0.000225067138671875</span></code></pre><p>通过运行结果显而易见，binsect的搜索效率远大于index的搜索效率</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectivePython </tag>
            
            <tag> Advices </tag>
            
            <tag> ReadingNotes </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
