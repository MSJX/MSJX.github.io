<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Test</title>
      <link href="/2018/12/29/test-1/"/>
      <url>/2018/12/29/test-1/</url>
      
        <content type="html"><![CDATA[<p>检验最后成果的时候到了！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/12/29/hello-world/"/>
      <url>/2018/12/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL存储过程</title>
      <link href="/2018/08/23/mysql-cun-chu-guo-cheng/"/>
      <url>/2018/08/23/mysql-cun-chu-guo-cheng/</url>
      
        <content type="html"><![CDATA[<p>本次主要记录MySQL数据库如何创建、使用存储过程</p><h3 id="什么是存储过程"><a href="#什么是存储过程" class="headerlink" title="什么是存储过程"></a>什么是存储过程</h3><ul><li><p>存储过程是存储在数据库服务器中的一组SQL语句，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数（需要时）来调用执行 。</p><p>存储过程可以用来封装特定功能，以便应用于不同的平台，可以看做对面向对象编程的模拟 </p></li></ul><h3 id="存储过程的优点"><a href="#存储过程的优点" class="headerlink" title="存储过程的优点"></a>存储过程的优点</h3><ul><li>存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般 SQL 语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。</li><li>当对数据库进行复杂操作时(如对多个表进行 Update,Insert,Query,Delete 时），可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。这些操作，如果用程序来完成，就变成了一条条的 SQL 语句，可能要多次连接数据库。而换成存储，只需要连接一次数据库就可以了。 </li><li>存储过程可以重复使用,可减少数据库开发人员的工作量。 </li><li>安全性高,可设定只有某此用户才具有对指定存储过程的使用权。 </li></ul><h3 id="存储过程的缺点"><a href="#存储过程的缺点" class="headerlink" title="存储过程的缺点"></a>存储过程的缺点</h3><ul><li>运行速度：对于很简单的SQL，存储过程没有什么优势。 </li><li>网络负荷：如果在存储过程中没有进行多次的数据交互，那么实际上网络传输量和直接使用SQL是一样的 。</li><li>开发调试：由于IDE的问题，存储过程的开发调试要比一般程序困难 。</li></ul><h3 id="创建MySQL存储过程"><a href="#创建MySQL存储过程" class="headerlink" title="创建MySQL存储过程"></a>创建MySQL存储过程</h3><ul><li><p>语法：</p><pre class=" language-mysql"><code class="language-mysql">delimiter //create procedure procedure_name(params)begin    procedure bodyend //delimiter;</code></pre><p>（<strong>注：</strong>在Navicat Lite中，新建函数，可直接在过程体中写入要完成的功能，非常方便。）</p></li><li><p>调用：</p><pre><code>call procedure_name(params)</code></pre></li><li><p>分隔符：</p><p>MySQL默认以”;”为分隔符，如果没有声明分隔符，则编译器会把存储过程当成SQL语句进行处理，因此编译过程会报错，所以要先用“DELIMITER //”声明当前段分隔符，让编译器把两个“//“之间的内容当做存储过程的代码，不会执行这些代码，“DELIMITER ;”意为把分隔符还原 。</p></li><li><p>参数：</p><p>存储过程根据需要可能会有输入、输出、输入输出参数，如果有多个参数用“,”分隔开。MySQL存储过程的参数用在存储过程的定义，共有三种类型：in、out、inout。</p><ul><li><p>in：</p><p>参数的值必须在调用存储过程前指定，在存储过程中修改该参数的值不能被返回</p><p>即类似JAVA中的值传递，传递的相当于参数的值的拷贝，而不是参数本身。</p></li><li><p>out：</p><p>该值可在存储过程内部被改变，并可返回，未在存储过程中赋值的话，则在存储过程中值为空</p><p>即类似JAVA中的引用传递，传递的是该参数本身的地址，该参数在存储过程中被修改相当于直接修改该参数本身。</p></li><li><p>inout：</p><p>具备IN、OUT的特性，在调用时指定，并可被改变和返回 。</p></li></ul></li><li><p>过程体（procedure body）：</p><p>完成某种特定的功能（自己指定）,过程体的开始与结束使用<strong>BEGIN</strong>和<strong>END</strong>进行标识 。</p></li><li><p>in实例：</p><pre class=" language-mysql"><code class="language-mysql">delimiter //create procedure pro_in(in p_in int)begin    select p_in;    set p_in = 1;    select p_in;end;//</code></pre><pre><code>mysql&gt; drop procedure if exists in_param;Query OK, 0 rows affected (0.00 sec)mysql&gt; delimiter //mysql&gt; create procedure in_param(in p_in int)    -&gt; begin    -&gt; select p_in;    -&gt; set p_in = 2;    -&gt; select p_in;    -&gt; end;    -&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; set @p_in=1;    -&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; call in_param(@p_in);    -&gt; //+------+| p_in |+------+|    1 |+------+1 row in set (0.00 sec)+------+| p_in |+------+|    2 |+------+1 row in set (0.03 sec)Query OK, 0 rows affected (0.06 sec)mysql&gt; select @p_in;    -&gt; //+-------+| @p_in |+-------+|     1 |+-------+1 row in set (0.00 sec)</code></pre><p>从运行结果可以得出，p_in虽然在存储过程中被修改了，但并不影响存储过程外的@p_in的值 。</p></li><li><p>out实例：</p><pre><code>delimiter //create procedure pro_out(out p_out int)begin    select p_out;    set p_out = 2;    select p_out;end;//</code></pre><pre><code>mysql&gt; delimiter //mysql&gt; create procedure out_param(out p_out int)    -&gt; begin    -&gt; select p_out;    -&gt; set p_out = 2;    -&gt; select p_out;    -&gt; end;    -&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; delimiter ;mysql&gt; set @p_out = 1;Query OK, 0 rows affected (0.00 sec)mysql&gt; call out_param(@p_out);+-------+| p_out |+-------+|  NULL |+-------+1 row in set (0.01 sec)+-------+| p_out |+-------+|     2 |+-------+1 row in set (0.03 sec)Query OK, 0 rows affected (0.06 sec)mysql&gt; select @p_out;+--------+| @p_out |+--------+|      2 |+--------+1 row in set (0.00 sec)</code></pre><p>从运行结果可以得出，p_out在存储过程中没被赋值的情况下是读取不到数据的，赋值后再存储过程外的@p_out的值也被修改了 。</p></li><li><p>inout实例：</p><pre><code>mysql&gt; delimiter //mysql&gt; create procedure inout_param(inout p_inout int)    -&gt; begin    -&gt; select p_inout;    -&gt; set p_inout = 2;    -&gt; select p_inout;    -&gt; end;    -&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; set @p_inout = 1;    -&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; call inout_param(@p_inout);    -&gt; //+---------+| p_inout |+---------+|       1 |+---------+1 row in set (0.00 sec)+---------+| p_inout |+---------+|       2 |+---------+1 row in set (0.03 sec)Query OK, 0 rows affected (0.06 sec)mysql&gt; select @p_inout;    -&gt; //+----------+| @p_inout |+----------+|        2 |+----------+1 row in set (0.00 sec)</code></pre><p>从运行结果可以得出，inout参数结合了in和out的特点，传进去的参数既可以读取又可以修改 。</p></li><li><p>删除存储过程：</p><ul><li><p>语法：</p><pre><code>drop procedure procedure_name;</code></pre></li><li><p>example:</p><pre><code>mysql&gt; drop procedure in_param;    -&gt; //Query OK, 0 rows affected (0.00 sec)</code></pre></li></ul></li><li><p>存储过程实现模糊查询（Navicat Lite为例）：</p><pre class=" language-mysql"><code class="language-mysql">create procedure pro_fruits_search_sort(in name varchar(20)):beginselect fname,fprice,fcount,fprice*fcount as total from fruits_table where fname like concat('%',name,'%'); end</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
