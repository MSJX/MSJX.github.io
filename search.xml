<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python AES and RSA</title>
      <link href="/2019/01/08/python-jia-mi-jie-mi/"/>
      <url>/2019/01/08/python-jia-mi-jie-mi/</url>
      
        <content type="html"><![CDATA[<h3 id="PyCryptodome包"><a href="#PyCryptodome包" class="headerlink" title="PyCryptodome包"></a>PyCryptodome包</h3><ul><li><strong>PyCryto</strong>应该是Python最著名的第三方库了，奈何<strong>PyCryto</strong>在2012年的时候就停止更新了。值得庆幸的是，在Python 3.x上有了一个名为<strong>PyCryptodome</strong>的库来代替<strong>PyCryto</strong>，下面简单介绍一下<strong>PyCryptodome</strong>这个库的用法，主要是AES结合RSA使用。</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><p><strong>Linux</strong></p><pre class=" language-python"><code class="language-python">pip install pycryptodome</code></pre></li><li><p><strong>Windows</strong></p><pre class=" language-Python"><code class="language-Python">pip install pycryptodomex</code></pre></li></ul><h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><ul><li><p><strong>加密</strong></p><p><code>`</code>python<br>from Crypto.Cipher import AES<br>from Crypto.Random import get_random_bytes</p><p>key = get_random_bytes(16)</p></li></ul><p>  def encrypt(content):<br>      data = content.encode(‘utf-8’)<br>      cipher = AES.new(key, AES.MODE_EAX)<br>      nonce = cipher.nonce<br>      cipher_text, tag = cipher.encrypt_and_digest(data)<br>      return cipher_text</p><p>  print(encrypt(‘Test Python AES’))</p><pre><code>  结果如下：</code></pre><p>  E:/company/1226/JsonRPC/en_decode/AES_crypto.py<br>  b’\x10e.\x0b\xcc\x1f\xdd\xb7\x1fE\x8a4M\xdc\xd5’</p><p>  Process finished with exit code 0<br>  <code>`</code></p>]]></content>
      
      
      <categories>
          
          <category> Python 加密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Basics</title>
      <link href="/2018/09/20/python-ji-chu/"/>
      <url>/2018/09/20/python-ji-chu/</url>
      
        <content type="html"><![CDATA[<ul><li><p>尽量用<strong>enumerate</strong>取代<strong>range</strong>：</p><p>Python提供了一个内置函数enumerate，可以把各种<strong>迭代器</strong>包装成为一个<strong>生成器</strong>，生成器每次产生一对输出值，前者表示<strong>循环下标</strong>，后者表示从迭代器获取到的下一个<strong>序列元素</strong>。这样写出来的代码非常简洁。</p><pre class=" language-python"><code class="language-python">flavor_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'vanilla'</span><span class="token punctuation">,</span><span class="token string">'chocolate'</span><span class="token punctuation">,</span><span class="token string">'pecan'</span><span class="token punctuation">,</span><span class="token string">'strawberry'</span><span class="token punctuation">]</span><span class="token keyword">for</span> i<span class="token punctuation">,</span>flavor <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>flavor_list<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%d : %s'</span> <span class="token operator">%</span> （<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span>）<span class="token punctuation">,</span>flavor<span class="token punctuation">)</span>）</code></pre><pre><code>&gt;&gt;&gt;1 : vanilla2 : chocolate3 : pecan4 : strawberry</code></pre><p>（<strong>注</strong>：列表的下标从0开始的）</p><p>还可以直接指定enumerate函数开始时所用的值，如下所示：</p><pre class=" language-python"><code class="language-python">flavor_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'vanilla'</span><span class="token punctuation">,</span><span class="token string">'chocolate'</span><span class="token punctuation">,</span><span class="token string">'pecan'</span><span class="token punctuation">,</span><span class="token string">'strawberry'</span><span class="token punctuation">]</span><span class="token keyword">for</span> i<span class="token punctuation">,</span>flavor <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>flavor_list<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%d : %s'</span> <span class="token operator">%</span> （i<span class="token punctuation">,</span>flavor<span class="token punctuation">)</span>）</code></pre><pre><code>&gt;&gt;&gt;1 : vanilla2 : chocolate3 : pecan4 : strawberry</code></pre><ul><li>enumerate函数提供了一种精简的写法，可以在遍历迭代器时获知每个元素的索引。</li><li>尽量用enumerate来改写那种将range与下标访问相结合的序列遍历代码。</li><li>可以给enumerate提供第二个参数，以指定开始计数时所用的值（默认是0）。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL存储过程</title>
      <link href="/2018/08/23/mysql-cun-chu-guo-cheng/"/>
      <url>/2018/08/23/mysql-cun-chu-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是存储过程"><a href="#什么是存储过程" class="headerlink" title="什么是存储过程"></a>什么是存储过程</h3><ul><li><p>存储过程是存储在数据库服务器中的一组SQL语句，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数（需要时）来调用执行 。</p><p>存储过程可以用来封装特定功能，以便应用于不同的平台，可以看做对面向对象编程的模拟 </p></li></ul><h3 id="存储过程的优点"><a href="#存储过程的优点" class="headerlink" title="存储过程的优点"></a>存储过程的优点</h3><ul><li>存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般 SQL 语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。</li><li>当对数据库进行复杂操作时(如对多个表进行 Update,Insert,Query,Delete 时），可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。这些操作，如果用程序来完成，就变成了一条条的 SQL 语句，可能要多次连接数据库。而换成存储，只需要连接一次数据库就可以了。 </li><li>存储过程可以重复使用,可减少数据库开发人员的工作量。 </li><li>安全性高,可设定只有某此用户才具有对指定存储过程的使用权。 </li></ul><h3 id="存储过程的缺点"><a href="#存储过程的缺点" class="headerlink" title="存储过程的缺点"></a>存储过程的缺点</h3><ul><li>运行速度：对于很简单的SQL，存储过程没有什么优势。 </li><li>网络负荷：如果在存储过程中没有进行多次的数据交互，那么实际上网络传输量和直接使用SQL是一样的 。</li><li>开发调试：由于IDE的问题，存储过程的开发调试要比一般程序困难 。</li></ul><h3 id="创建MySQL存储过程"><a href="#创建MySQL存储过程" class="headerlink" title="创建MySQL存储过程"></a>创建MySQL存储过程</h3><ul><li><p>语法：</p><pre class=" language-mysql"><code class="language-mysql">delimiter //create procedure procedure_name(params)begin    procedure bodyend //delimiter;</code></pre><p>（<strong>注：</strong>在Navicat Lite中，新建函数，可直接在过程体中写入要完成的功能，非常方便。）</p></li><li><p>调用：</p><pre><code>call procedure_name(params)</code></pre></li><li><p>分隔符：</p><p>MySQL默认以”;”为分隔符，如果没有声明分隔符，则编译器会把存储过程当成SQL语句进行处理，因此编译过程会报错，所以要先用“DELIMITER //”声明当前段分隔符，让编译器把两个“//“之间的内容当做存储过程的代码，不会执行这些代码，“DELIMITER ;”意为把分隔符还原 。</p></li><li><p>参数：</p><p>存储过程根据需要可能会有输入、输出、输入输出参数，如果有多个参数用“,”分隔开。MySQL存储过程的参数用在存储过程的定义，共有三种类型：in、out、inout。</p><ul><li><p>in：</p><p>参数的值必须在调用存储过程前指定，在存储过程中修改该参数的值不能被返回</p><p>即类似JAVA中的值传递，传递的相当于参数的值的拷贝，而不是参数本身。</p></li><li><p>out：</p><p>该值可在存储过程内部被改变，并可返回，未在存储过程中赋值的话，则在存储过程中值为空</p><p>即类似JAVA中的引用传递，传递的是该参数本身的地址，该参数在存储过程中被修改相当于直接修改该参数本身。</p></li><li><p>inout：</p><p>具备IN、OUT的特性，在调用时指定，并可被改变和返回 。</p></li></ul></li><li><p>过程体（procedure body）：</p><p>完成某种特定的功能（自己指定）,过程体的开始与结束使用<strong>BEGIN</strong>和<strong>END</strong>进行标识 。</p></li><li><p>in实例：</p><pre class=" language-mysql"><code class="language-mysql">delimiter //create procedure pro_in(in p_in int)begin    select p_in;    set p_in = 1;    select p_in;end;//</code></pre><pre><code>mysql&gt; drop procedure if exists in_param;Query OK, 0 rows affected (0.00 sec)mysql&gt; delimiter //mysql&gt; create procedure in_param(in p_in int)    -&gt; begin    -&gt; select p_in;    -&gt; set p_in = 2;    -&gt; select p_in;    -&gt; end;    -&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; set @p_in=1;    -&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; call in_param(@p_in);    -&gt; //+------+| p_in |+------+|    1 |+------+1 row in set (0.00 sec)+------+| p_in |+------+|    2 |+------+1 row in set (0.03 sec)Query OK, 0 rows affected (0.06 sec)mysql&gt; select @p_in;    -&gt; //+-------+| @p_in |+-------+|     1 |+-------+1 row in set (0.00 sec)</code></pre><p>从运行结果可以得出，p_in虽然在存储过程中被修改了，但并不影响存储过程外的@p_in的值 。</p></li><li><p>out实例：</p><pre><code>delimiter //create procedure pro_out(out p_out int)begin    select p_out;    set p_out = 2;    select p_out;end;//</code></pre><pre><code>mysql&gt; delimiter //mysql&gt; create procedure out_param(out p_out int)    -&gt; begin    -&gt; select p_out;    -&gt; set p_out = 2;    -&gt; select p_out;    -&gt; end;    -&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; delimiter ;mysql&gt; set @p_out = 1;Query OK, 0 rows affected (0.00 sec)mysql&gt; call out_param(@p_out);+-------+| p_out |+-------+|  NULL |+-------+1 row in set (0.01 sec)+-------+| p_out |+-------+|     2 |+-------+1 row in set (0.03 sec)Query OK, 0 rows affected (0.06 sec)mysql&gt; select @p_out;+--------+| @p_out |+--------+|      2 |+--------+1 row in set (0.00 sec)</code></pre><p>从运行结果可以得出，p_out在存储过程中没被赋值的情况下是读取不到数据的，赋值后再存储过程外的@p_out的值也被修改了 。</p></li><li><p>inout实例：</p><pre><code>mysql&gt; delimiter //mysql&gt; create procedure inout_param(inout p_inout int)    -&gt; begin    -&gt; select p_inout;    -&gt; set p_inout = 2;    -&gt; select p_inout;    -&gt; end;    -&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; set @p_inout = 1;    -&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; call inout_param(@p_inout);    -&gt; //+---------+| p_inout |+---------+|       1 |+---------+1 row in set (0.00 sec)+---------+| p_inout |+---------+|       2 |+---------+1 row in set (0.03 sec)Query OK, 0 rows affected (0.06 sec)mysql&gt; select @p_inout;    -&gt; //+----------+| @p_inout |+----------+|        2 |+----------+1 row in set (0.00 sec)</code></pre><p>从运行结果可以得出，inout参数结合了in和out的特点，传进去的参数既可以读取又可以修改 。</p></li><li><p>删除存储过程：</p><ul><li><p>语法：</p><pre><code>drop procedure procedure_name;</code></pre></li><li><p>example:</p><pre><code>mysql&gt; drop procedure in_param;    -&gt; //Query OK, 0 rows affected (0.00 sec)</code></pre></li></ul></li><li><p>存储过程实现模糊查询（Navicat Lite为例）：</p><pre class=" language-mysql"><code class="language-mysql">create procedure pro_fruits_search_sort(in name varchar(20)):beginselect fname,fprice,fcount,fprice*fcount as total from fruits_table where fname like concat('%',name,'%'); end</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
