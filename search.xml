<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python AES and RSA</title>
      <link href="/2019/01/08/python-jia-mi-jie-mi/"/>
      <url>/2019/01/08/python-jia-mi-jie-mi/</url>
      
        <content type="html"><![CDATA[<h3 id="PyCryptodome包"><a href="#PyCryptodome包" class="headerlink" title="PyCryptodome包"></a>PyCryptodome包</h3><p>​    <font color="red"><strong>PyCryto</strong></font>应该是Python最著名的第三方库了，奈何<strong><font color="red">PyCryto</font></strong>在2012年的时候就停止更新了。值得庆幸的是，在Python 3.x上有了一个名为<strong><font color="red">PyCryptodome</font></strong>的库来代替<strong><font color="red">PyCryto</font></strong>，下面简单介绍一下<strong><font color="red">PyCryptodome</font></strong>这个库的用法，主要是AES结合RSA使用。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><p><strong>Linux</strong></p><pre class=" language-python"><code class="language-python">pip install pycryptodome</code></pre></li><li><p><strong>Windows</strong></p><pre class=" language-Python"><code class="language-Python">pip install pycryptodomex</code></pre></li></ul><h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><p>​    <strong>高级加密标准</strong>（英文：<strong>Advanced Encryption Standard</strong>，缩写：<strong>AES</strong>），在密码学中又称<strong>Rijndael加密法</strong>，是美国联邦政府采用的一种区块加密标准。</p><ul><li><p><strong>加密</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Cipher <span class="token keyword">import</span> AES<span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Random <span class="token keyword">import</span> get_random_byteskey <span class="token operator">=</span> get_random_bytes<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">encrypto</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>    data <span class="token operator">=</span> content<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    cipher <span class="token operator">=</span> AES<span class="token punctuation">.</span>new<span class="token punctuation">(</span>key<span class="token punctuation">,</span> AES<span class="token punctuation">.</span>MODE_EAX<span class="token punctuation">)</span>    nonce <span class="token operator">=</span> nonce    cipher_text<span class="token punctuation">,</span> tag <span class="token operator">=</span> cipher<span class="token punctuation">.</span>encrypt_and_digest<span class="token punctuation">(</span>data<span class="token punctuation">)</span>    <span class="token keyword">return</span> cipher_text<span class="token keyword">print</span><span class="token punctuation">(</span>encrypt<span class="token punctuation">(</span><span class="token string">'Test Python AES'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><pre class=" language-python"><code class="language-python">E<span class="token punctuation">:</span><span class="token operator">/</span>company<span class="token operator">/</span><span class="token number">1226</span><span class="token operator">/</span>JsonRPC<span class="token operator">/</span>en_decode<span class="token operator">/</span>AES_crypto<span class="token punctuation">.</span>pyb<span class="token string">'u\xed\xdc=D\x17\x83\xac\xbf\xc5\xe5p5A\x1a'</span>Process finished <span class="token keyword">with</span> exit code <span class="token number">0</span></code></pre></li></ul><ul><li><p><strong>解密</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Cipher <span class="token keyword">import</span> AES<span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Random <span class="token keyword">import</span> get_random_byteskey <span class="token operator">=</span> get_random_bytes<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">decrypt</span><span class="token punctuation">(</span>cipher_text<span class="token punctuation">)</span><span class="token punctuation">:</span>    cipher <span class="token operator">=</span> AES<span class="token punctuation">.</span>new<span class="token punctuation">(</span>key<span class="token punctuation">,</span> AES<span class="token punctuation">.</span>MODE_EAX<span class="token punctuation">,</span> nonce<span class="token operator">=</span>nonce<span class="token punctuation">)</span>    plaintext <span class="token operator">=</span> <span class="token punctuation">(</span>cipher<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span>cipher_text<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        cipher<span class="token punctuation">.</span>verify<span class="token punctuation">(</span>tag<span class="token punctuation">)</span>        <span class="token keyword">return</span> plaintext    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"key incorrect or message corrupted"</span></code></pre><pre class=" language-python"><code class="language-python">E<span class="token punctuation">:</span><span class="token operator">/</span>company<span class="token operator">/</span><span class="token number">1226</span><span class="token operator">/</span>JsonRPC<span class="token operator">/</span>en_decode<span class="token operator">/</span>AES_crypto<span class="token punctuation">.</span>pyTest Python AESProcess finished <span class="token keyword">with</span> exit code <span class="token number">0</span></code></pre><p>解密过程中的<strong>key、nonce、tag</strong>必须与<strong>cipher_text</strong>在加密过程中生成的<strong>key、nonce、tag</strong>一致，否则会报错。</p></li><li><p><strong>封装成一个类</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Cipher <span class="token keyword">import</span> AES<span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Random <span class="token keyword">import</span> get_random_bytes<span class="token keyword">class</span> <span class="token class-name">AESCrypto</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    key <span class="token operator">=</span> get_random_bytes<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 加密</span>    <span class="token keyword">def</span> <span class="token function">encrypt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">:</span>        data <span class="token operator">=</span> content<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>        cipher <span class="token operator">=</span> AES<span class="token punctuation">.</span>new<span class="token punctuation">(</span>self<span class="token punctuation">.</span>key<span class="token punctuation">,</span> AES<span class="token punctuation">.</span>MODE_EAX<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>nonce <span class="token operator">=</span> cipher<span class="token punctuation">.</span>nonce        self<span class="token punctuation">.</span>cipher_text<span class="token punctuation">,</span> self<span class="token punctuation">.</span>tag <span class="token operator">=</span> cipher<span class="token punctuation">.</span>encrypt_and_digest<span class="token punctuation">(</span>data<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>cipher_text    <span class="token comment" spellcheck="true"># 解密</span>    <span class="token keyword">def</span> <span class="token function">decrypt</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        cipher <span class="token operator">=</span> AES<span class="token punctuation">.</span>new<span class="token punctuation">(</span>self<span class="token punctuation">.</span>key<span class="token punctuation">,</span> AES<span class="token punctuation">.</span>MODE_EAX<span class="token punctuation">,</span> nonce<span class="token operator">=</span>self<span class="token punctuation">.</span>nonce<span class="token punctuation">)</span>        plaintext <span class="token operator">=</span> <span class="token punctuation">(</span>cipher<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span>self<span class="token punctuation">.</span>cipher_text<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            cipher<span class="token punctuation">.</span>verify<span class="token punctuation">(</span>self<span class="token punctuation">.</span>tag<span class="token punctuation">)</span>            <span class="token keyword">return</span> plaintext        <span class="token keyword">except</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">"key incorrect or message corrupted"</span></code></pre></li></ul><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>​    <strong>RSA加密算法</strong>是一种<font color="red"><strong>非对称加密算法</strong></font>&gt;。在公开密钥加密和电子商业中RSA被广泛使用。</p><p>​    该算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但那时想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥，即公钥，而两个大素数组合成私钥。公钥是可发布的供任何人使用，私钥则为自己所有，供解密之用</p><ul><li><p><strong>Linux安装</strong></p><pre class=" language-python"><code class="language-python">pip install rsa</code></pre></li></ul><ul><li><p><strong>使用</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> rsa<span class="token comment" spellcheck="true"># 加密</span><span class="token keyword">def</span> <span class="token function">rsa_encrypted</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 生成公钥、私钥</span>    pub_key<span class="token punctuation">,</span> priv_key <span class="token operator">=</span> rsa<span class="token punctuation">.</span>newkeys<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 明文编码格式</span>    content <span class="token operator">=</span> msg<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 公钥加密</span>    crypto <span class="token operator">=</span> rsa<span class="token punctuation">.</span>encrypt<span class="token punctuation">(</span>content<span class="token punctuation">,</span> pub_key<span class="token punctuation">)</span>    <span class="token keyword">return</span> crypto<span class="token punctuation">,</span> priv_key<span class="token comment" spellcheck="true"># 解密</span><span class="token keyword">def</span> <span class="token function">rsa_decrypted</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> priv_key<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 私钥解密</span>    content <span class="token operator">=</span> rsa<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span>msg<span class="token punctuation">,</span> priv_key<span class="token punctuation">)</span>    data <span class="token operator">=</span> content<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> data</code></pre><p>如果单独使用<strong>RSA</strong>进行加密的话，加密的内容长度会受到<strong>公钥</strong>和<strong>私钥</strong>的<font color="red"><strong>bytes</strong></font>影响，所以，这个时候会就需要用到文章开头所说的，<strong>AES + RSA</strong>来进行加密。</p></li></ul><h3 id="AES-RSA"><a href="#AES-RSA" class="headerlink" title="AES + RSA"></a>AES + RSA</h3><ul><li><p><strong>生成一个RSA密钥</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>PublicKey <span class="token keyword">import</span> RSAcode <span class="token operator">=</span> <span class="token string">'nooneknows'</span>key <span class="token operator">=</span> RSA<span class="token punctuation">.</span>generate<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span>encrypted_key <span class="token operator">=</span> key<span class="token punctuation">.</span>exportKey<span class="token punctuation">(</span>passphrase<span class="token operator">=</span>code<span class="token punctuation">,</span> pkcs<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span>                              protection<span class="token operator">=</span><span class="token string">"scryptAndAES128-CBC"</span><span class="token punctuation">)</span><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'private_key.pem'</span><span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>encrypted_key<span class="token punctuation">)</span><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'public_key.pem'</span><span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>key<span class="token punctuation">.</span>publickey<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>exportKey<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>首先我们从<strong><font color="red">Crypto.PublicKey</font></strong> 引入 <strong>RSA</strong>，然后创建一个密码。接下来我们生成一个2048位的<strong>RSA</strong>对象实例。我们需要调用 RSA 实例的 <strong>exportKey</strong> 方法并传递给它刚刚创建的密码，PKCS 标准算法将会用它保护我们的私钥。接下来我们将生成的私钥写入文件。</p><p>下一步我们通过 RSA 实例的 <strong>publickey</strong> 方法生成公钥，我们在这段代码中用了简写的方式将 <strong>publickey</strong> 和 <strong>exportKey</strong> 方法串接起来，最后也将结果写入文件。</p></li><li><p><strong>对文件进行加密</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>PublicKey <span class="token keyword">import</span> RSA<span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Random <span class="token keyword">import</span> get_random_bytes<span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Cipher <span class="token keyword">import</span> AES<span class="token punctuation">,</span> PKCS1_OAEP<span class="token keyword">def</span> <span class="token function">encrypt</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'encrypted_data.bin'</span><span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> out_file<span class="token punctuation">:</span>        recipient_key <span class="token operator">=</span> RSA<span class="token punctuation">.</span>import_key<span class="token punctuation">(</span>            open<span class="token punctuation">(</span><span class="token string">'public.pem'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        session_key <span class="token operator">=</span> get_random_bytes<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span>        cipher_rsa <span class="token operator">=</span> PKCS1_OAEP<span class="token punctuation">.</span>new<span class="token punctuation">(</span>recipient_key<span class="token punctuation">)</span>        out_file<span class="token punctuation">.</span>write<span class="token punctuation">(</span>cipher_rsa<span class="token punctuation">.</span>encrypt<span class="token punctuation">(</span>session_key<span class="token punctuation">)</span><span class="token punctuation">)</span>        cipher_aes <span class="token operator">=</span> AES<span class="token punctuation">.</span>new<span class="token punctuation">(</span>session_key<span class="token punctuation">,</span> AES<span class="token punctuation">.</span>MODE_EAX<span class="token punctuation">)</span>        data <span class="token operator">=</span> content<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>        cipher_text<span class="token punctuation">,</span> tag <span class="token operator">=</span> cipher_aes<span class="token punctuation">.</span>encrypt_and_digest<span class="token punctuation">(</span>data<span class="token punctuation">)</span>        out_file<span class="token punctuation">.</span>write<span class="token punctuation">(</span>cipher_aes<span class="token punctuation">.</span>nonce<span class="token punctuation">)</span>        out_file<span class="token punctuation">.</span>write<span class="token punctuation">(</span>tag<span class="token punctuation">)</span>        out_file<span class="token punctuation">.</span>write<span class="token punctuation">(</span>cipher_text<span class="token punctuation">)</span>    <span class="token keyword">return</span> cipher_text</code></pre><p>前三行完成对<font color="red"><strong>PyCryptodome</strong></font>的引入，接下来打开将要写入的文件。然后我们将公钥读入变量并创建一个16字节长的 <strong>session key</strong>。在这个例子中我们用了混合加密方法，因此我们使用最优非对称加密填充的 <strong>PKCS#1 OAEP</strong>。这让我们可以将任意长度的数据写入文件。接下来我们创建 <strong>AES</strong> 密文，创建一些数据并进行加密，这一方法会返回加密后的文本和 <strong>MAC</strong> 值。最终我们将 <code>nonce</code>，<code>MAC</code>(或<code>tag</code>)以及加密后的文本写入文件。</p><p>说明一下，<code>nonce</code> 是一个任意数字，仅用于密文通信。它们通常是随机或伪随机数。对于 <strong>AES</strong> 来说，它的长度至少要是16位。你可以用你的文本编辑器打开加密后的文件看一下，只能看到一堆乱码。</p></li><li><p><strong>对文件进行解密</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>PublicKey <span class="token keyword">import</span> RSA<span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Random <span class="token keyword">import</span> get_random_bytes<span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Cipher <span class="token keyword">import</span> AES<span class="token punctuation">,</span> PKCS1_OAEP<span class="token keyword">def</span> <span class="token function">decrypt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    secret_code <span class="token operator">=</span> <span class="token string">'nooneknows'</span>    <span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'encrypted_data.bin'</span><span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fp<span class="token punctuation">:</span>        private_key <span class="token operator">=</span> RSA<span class="token punctuation">.</span>import_key<span class="token punctuation">(</span>            open<span class="token punctuation">(</span><span class="token string">'private.pem'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> passphrase<span class="token operator">=</span>secret_code<span class="token punctuation">)</span>        enc_session_key<span class="token punctuation">,</span> nonce<span class="token punctuation">,</span> tag<span class="token punctuation">,</span> cipher_text <span class="token operator">=</span> <span class="token punctuation">[</span>fp<span class="token punctuation">.</span>read<span class="token punctuation">(</span>x<span class="token punctuation">)</span>                                                     <span class="token keyword">for</span> x <span class="token keyword">in</span>             <span class="token punctuation">(</span>private_key<span class="token punctuation">.</span>size_in_bytes<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                                               <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        cipher_rsa <span class="token operator">=</span> PKCS1_OAEP<span class="token punctuation">.</span>new<span class="token punctuation">(</span>private_key<span class="token punctuation">)</span>        cipher_aes <span class="token operator">=</span> AES<span class="token punctuation">.</span>new<span class="token punctuation">(</span>session_key<span class="token punctuation">,</span> AES<span class="token punctuation">.</span>MODE_EAX<span class="token punctuation">,</span> nonce<span class="token punctuation">)</span>        data <span class="token operator">=</span> cipher_aes<span class="token punctuation">.</span>decrypt_and_verify<span class="token punctuation">(</span>cipher_text<span class="token punctuation">,</span> tag<span class="token punctuation">)</span>    <span class="token keyword">return</span> data<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span></code></pre><p>在这个例子中，我们以二进制模式打开加密文件，然后导入私钥。要注意在导入私钥的时候，必须给出你的密码，即在生成<strong>RSA</strong>密钥时自己定义的<code>code = &#39;nooneknows&#39;</code>，否则将会出错。接下来我们读取加密文件，需要注意的是先读取私钥，然后是16位长的 <code>nonce</code>，接下来是另外 16 位长的标签，最后剩下的才是我们的数据。</p><p>接下来我们需要解密 <strong>session key</strong>，重新生成 <strong>AES key</strong> 并解密数据。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Basics</title>
      <link href="/2018/09/20/python-ji-chu/"/>
      <url>/2018/09/20/python-ji-chu/</url>
      
        <content type="html"><![CDATA[<ul><li><p>尽量用<strong>enumerate</strong>取代<strong>range</strong>：</p><p>Python提供了一个内置函数enumerate，可以把各种<strong>迭代器</strong>包装成为一个<strong>生成器</strong>，生成器每次产生一对输出值，前者表示<strong>循环下标</strong>，后者表示从迭代器获取到的下一个<strong>序列元素</strong>。这样写出来的代码非常简洁。</p><pre class=" language-python"><code class="language-python">flavor_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'vanilla'</span><span class="token punctuation">,</span><span class="token string">'chocolate'</span><span class="token punctuation">,</span><span class="token string">'pecan'</span><span class="token punctuation">,</span><span class="token string">'strawberry'</span><span class="token punctuation">]</span><span class="token keyword">for</span> i<span class="token punctuation">,</span>flavor <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>flavor_list<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%d : %s'</span> <span class="token operator">%</span> （<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span>）<span class="token punctuation">,</span>flavor<span class="token punctuation">)</span>）</code></pre><pre><code>&gt;&gt;&gt;1 : vanilla2 : chocolate3 : pecan4 : strawberry</code></pre><p>（<strong>注</strong>：列表的下标从0开始的）</p><p>还可以直接指定enumerate函数开始时所用的值，如下所示：</p><pre class=" language-python"><code class="language-python">flavor_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'vanilla'</span><span class="token punctuation">,</span><span class="token string">'chocolate'</span><span class="token punctuation">,</span><span class="token string">'pecan'</span><span class="token punctuation">,</span><span class="token string">'strawberry'</span><span class="token punctuation">]</span><span class="token keyword">for</span> i<span class="token punctuation">,</span>flavor <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>flavor_list<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%d : %s'</span> <span class="token operator">%</span> （i<span class="token punctuation">,</span>flavor<span class="token punctuation">)</span>）</code></pre><pre><code>&gt;&gt;&gt;1 : vanilla2 : chocolate3 : pecan4 : strawberry</code></pre><ul><li>enumerate函数提供了一种精简的写法，可以在遍历迭代器时获知每个元素的索引。</li><li>尽量用enumerate来改写那种将range与下标访问相结合的序列遍历代码。</li><li>可以给enumerate提供第二个参数，以指定开始计数时所用的值（默认是0）。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL存储过程</title>
      <link href="/2018/08/23/mysql-cun-chu-guo-cheng/"/>
      <url>/2018/08/23/mysql-cun-chu-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是存储过程"><a href="#什么是存储过程" class="headerlink" title="什么是存储过程"></a>什么是存储过程</h3><ul><li><p>存储过程是存储在数据库服务器中的一组SQL语句，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数（需要时）来调用执行 。</p><p>存储过程可以用来封装特定功能，以便应用于不同的平台，可以看做对面向对象编程的模拟 </p></li></ul><h3 id="存储过程的优点"><a href="#存储过程的优点" class="headerlink" title="存储过程的优点"></a>存储过程的优点</h3><ul><li>存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般 SQL 语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。</li><li>当对数据库进行复杂操作时(如对多个表进行 Update,Insert,Query,Delete 时），可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。这些操作，如果用程序来完成，就变成了一条条的 SQL 语句，可能要多次连接数据库。而换成存储，只需要连接一次数据库就可以了。 </li><li>存储过程可以重复使用,可减少数据库开发人员的工作量。 </li><li>安全性高,可设定只有某此用户才具有对指定存储过程的使用权。 </li></ul><h3 id="存储过程的缺点"><a href="#存储过程的缺点" class="headerlink" title="存储过程的缺点"></a>存储过程的缺点</h3><ul><li>运行速度：对于很简单的SQL，存储过程没有什么优势。 </li><li>网络负荷：如果在存储过程中没有进行多次的数据交互，那么实际上网络传输量和直接使用SQL是一样的 。</li><li>开发调试：由于IDE的问题，存储过程的开发调试要比一般程序困难 。</li></ul><h3 id="创建MySQL存储过程"><a href="#创建MySQL存储过程" class="headerlink" title="创建MySQL存储过程"></a>创建MySQL存储过程</h3><ul><li><p>语法：</p><pre class=" language-mysql"><code class="language-mysql">delimiter //create procedure procedure_name(params)begin    procedure bodyend //delimiter;</code></pre><p>（<strong>注：</strong>在Navicat Lite中，新建函数，可直接在过程体中写入要完成的功能，非常方便。）</p></li><li><p>调用：</p><pre><code>call procedure_name(params)</code></pre></li><li><p>分隔符：</p><p>MySQL默认以”;”为分隔符，如果没有声明分隔符，则编译器会把存储过程当成SQL语句进行处理，因此编译过程会报错，所以要先用“DELIMITER //”声明当前段分隔符，让编译器把两个“//“之间的内容当做存储过程的代码，不会执行这些代码，“DELIMITER ;”意为把分隔符还原 。</p></li><li><p>参数：</p><p>存储过程根据需要可能会有输入、输出、输入输出参数，如果有多个参数用“,”分隔开。MySQL存储过程的参数用在存储过程的定义，共有三种类型：in、out、inout。</p><ul><li><p>in：</p><p>参数的值必须在调用存储过程前指定，在存储过程中修改该参数的值不能被返回</p><p>即类似JAVA中的值传递，传递的相当于参数的值的拷贝，而不是参数本身。</p></li><li><p>out：</p><p>该值可在存储过程内部被改变，并可返回，未在存储过程中赋值的话，则在存储过程中值为空</p><p>即类似JAVA中的引用传递，传递的是该参数本身的地址，该参数在存储过程中被修改相当于直接修改该参数本身。</p></li><li><p>inout：</p><p>具备IN、OUT的特性，在调用时指定，并可被改变和返回 。</p></li></ul></li><li><p>过程体（procedure body）：</p><p>完成某种特定的功能（自己指定）,过程体的开始与结束使用<strong>BEGIN</strong>和<strong>END</strong>进行标识 。</p></li><li><p>in实例：</p><pre class=" language-mysql"><code class="language-mysql">delimiter //create procedure pro_in(in p_in int)begin    select p_in;    set p_in = 1;    select p_in;end;//</code></pre><pre><code>mysql&gt; drop procedure if exists in_param;Query OK, 0 rows affected (0.00 sec)mysql&gt; delimiter //mysql&gt; create procedure in_param(in p_in int)    -&gt; begin    -&gt; select p_in;    -&gt; set p_in = 2;    -&gt; select p_in;    -&gt; end;    -&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; set @p_in=1;    -&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; call in_param(@p_in);    -&gt; //+------+| p_in |+------+|    1 |+------+1 row in set (0.00 sec)+------+| p_in |+------+|    2 |+------+1 row in set (0.03 sec)Query OK, 0 rows affected (0.06 sec)mysql&gt; select @p_in;    -&gt; //+-------+| @p_in |+-------+|     1 |+-------+1 row in set (0.00 sec)</code></pre><p>从运行结果可以得出，p_in虽然在存储过程中被修改了，但并不影响存储过程外的@p_in的值 。</p></li><li><p>out实例：</p><pre><code>delimiter //create procedure pro_out(out p_out int)begin    select p_out;    set p_out = 2;    select p_out;end;//</code></pre><pre><code>mysql&gt; delimiter //mysql&gt; create procedure out_param(out p_out int)    -&gt; begin    -&gt; select p_out;    -&gt; set p_out = 2;    -&gt; select p_out;    -&gt; end;    -&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; delimiter ;mysql&gt; set @p_out = 1;Query OK, 0 rows affected (0.00 sec)mysql&gt; call out_param(@p_out);+-------+| p_out |+-------+|  NULL |+-------+1 row in set (0.01 sec)+-------+| p_out |+-------+|     2 |+-------+1 row in set (0.03 sec)Query OK, 0 rows affected (0.06 sec)mysql&gt; select @p_out;+--------+| @p_out |+--------+|      2 |+--------+1 row in set (0.00 sec)</code></pre><p>从运行结果可以得出，p_out在存储过程中没被赋值的情况下是读取不到数据的，赋值后再存储过程外的@p_out的值也被修改了 。</p></li><li><p>inout实例：</p><pre><code>mysql&gt; delimiter //mysql&gt; create procedure inout_param(inout p_inout int)    -&gt; begin    -&gt; select p_inout;    -&gt; set p_inout = 2;    -&gt; select p_inout;    -&gt; end;    -&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; set @p_inout = 1;    -&gt; //Query OK, 0 rows affected (0.00 sec)mysql&gt; call inout_param(@p_inout);    -&gt; //+---------+| p_inout |+---------+|       1 |+---------+1 row in set (0.00 sec)+---------+| p_inout |+---------+|       2 |+---------+1 row in set (0.03 sec)Query OK, 0 rows affected (0.06 sec)mysql&gt; select @p_inout;    -&gt; //+----------+| @p_inout |+----------+|        2 |+----------+1 row in set (0.00 sec)</code></pre><p>从运行结果可以得出，inout参数结合了in和out的特点，传进去的参数既可以读取又可以修改 。</p></li><li><p>删除存储过程：</p><ul><li><p>语法：</p><pre><code>drop procedure procedure_name;</code></pre></li><li><p>example:</p><pre><code>mysql&gt; drop procedure in_param;    -&gt; //Query OK, 0 rows affected (0.00 sec)</code></pre></li></ul></li><li><p>存储过程实现模糊查询（Navicat Lite为例）：</p><pre class=" language-mysql"><code class="language-mysql">create procedure pro_fruits_search_sort(in name varchar(20)):beginselect fname,fprice,fcount,fprice*fcount as total from fruits_table where fname like concat('%',name,'%'); end</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
